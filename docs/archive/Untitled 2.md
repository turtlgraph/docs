  

JR

James RossMax plan

GRAPHITE Naming Origins

[](https://claude.ai/new)

JR

do you remember GRAPHITE

Edit

Probed memory for context about GRAPHITE.

2s

I'll check my recent memory first to see what we've been working on, including anything about GRAPHITE.

B

recent_activity

Probed recent activity for GRAPHITE context and details.

1s

B

search

I found mention in "ATLAS: Final Naming Decision for Asset Graph Format" but the content shown is

1s

B

read_note

Request

``{ `identifier`: `ATLAS: Final Naming Decision for Asset Graph Format` }``

Response

``--- title: 'ATLAS: Final Naming Decision for Asset Graph Format' type: note permalink: projects/atlas-final-naming-decision-for-asset-graph-format tags: - '#atlas-naming' - '#branding-decision' - '#trademark-analysis' - '#final-specification' --- # ATLAS: Final Naming Decision for Asset Graph Format ## User's Expert Analysis - Collision Risk Assessment ### Naming Options Evaluated | Name | Vibe | Collision Risk | Score | |------|------|----------------|-------| | **BOLT** | ‚ö° Fast, punchy, dev-friendly | LLVM Bolt, Facebook BOLT cache | **7** | | **FLUX** | üö∞ Slick, flowing | FluxCD, React Flux, InfluxDB | **5** | | **NEXUS** | üîó Central hub, big-league | Sonatype Nexus, Google Nexus | **6** | | **ATLAS** | üó∫Ô∏è Map/library vibe | TensorFlow Atlas, Netflix Atlas | **8** | | **OMNI** | üåê All-encompassing | OmniAuth, OmniDB, OmniRig | **4** | | **SAGE** | üßô‚Äç‚ôÇÔ∏è Wise & tidy | SageMath, Sage accounting | **5** | | **VAULT** | üîí Secure, heavy | HashiCorp Vault (huge) | **4** | | **FORGE** | üî® Industrial, modder-friendly | GitLab Forge, CurseForge | **6** | | **GRAPHITE** | üñ§ Lightweight carbon, graph pun | Graphite metrics daemon | **8** | ## Final Decision: **ATLAS** üó∫Ô∏è ### Why ATLAS Wins #### Perfect Metaphor Alignment - **Traditional atlas** = map showing how places connect - **Asset atlas** = graph showing how assets connect - **Both** help navigate complex interconnected systems - **Both** are reference materials consulted repeatedly #### Professional Credibility ```bash atlas: add zero-copy asset atlas loader ``` - **Reads like serious systems software** - **Zero cringe factor** (timeless, professional) - **Natural verbification** ("atlas the bundle", "atlas pack") - **Enterprise-ready terminology** #### Collision Risk Assessment - **Broad trademark usage** but not owned in asset/gamedev domain - **No major direct conflicts** in target space - **SEO manageable** with "Asset Atlas" qualification - **Legal risk minimal** compared to alternatives #### Linus Test Results - **ATLAS**: Nod + "Makes sense, applied" - **GRAPHITE**: "Fine, whatever" - **NEXUS**: Raised eyebrow + "Is this Maven garbage?" - **BOLT**: "Didn't Facebook already name something this?" ### Complete Rebrand Implementation #### File Format - **Extension**: `.atlas` (instead of `.bgaf`) - **MIME type**: `application/x-atlas` - **Magic number**: `"ATLS"` (instead of `"BGAF"`) #### API Naming ```c atlas_bundle* atlas_open(const char* path); const atlas_graph* atlas_root(const atlas_bundle*); const char* atlas_string(const atlas_bundle*, uint32_t id); void atlas_close(atlas_bundle*); ``` #### CLI Tools ```bash atlas info bundle.atlas # Professional, clear atlas verify bundle.atlas # Authoritative atlas pack assets/ out.atlas # Action-oriented atlas diff old.atlas new.atlas # Comprehensive toolchain ``` #### Documentation Structure - **"Atlas Format Specification"** - **"Atlas Performance Guide"** - **"Atlas Integration Manual"** - **"Atlas Security Model"** ### Marketing/Communication Benefits #### Natural Language Flow - **"Asset Atlas"** - immediately understandable concept - **"Atlas bundles"** - sounds professional and substantial - **"Atlas format"** - implies standardization and reliability - **"Atlas pipeline"** - enterprise-ready asset management #### Professional Staying Power - **10-year test**: `cmake .. -DENABLE_ATLAS_LOADER=ON` sounds like established tech - **Industry adoption**: Name that game engines would actually use - **Academic credibility**: Suitable for research papers and technical documentation - **Enterprise appeal**: Name that CTOs and technical directors approve ## Technical Implementation Changes ### Header Structure ```c typedef struct { char magic[4]; // "ATLS" instead of "BGAF" uint8_t version; // 0x01 (start fresh) // ... rest unchanged } atlas_hdr; ``` ### Commit Message Template ``` atlas: add Atlas asset format loader Provide a mmap-based loader for Atlas bundles. Highlights: * 40-bit offsets (_BitInt(40)) ‚Äì address files up to 1 TiB * Pointer hydration ‚Äì zero-copy after initial page-fault walk * Integrity ‚Äì per-chunk CRC-32 plus BLAKE3 Merkle tree * Optional zstd compression with dictionary training * NUMA-aware arena allocator and thread affinity Test matrix: x86-64, arm64, i386 All builds pass ASan, UBSan, ThreadSanitizer Performance: 182ms open-to-ready (1 GiB bundle, 8-core Zen 4) Signed-off-by: [Name] <email> ``` ## Final Assessment **User's analysis conclusion**: "ATLAS ‚Äî classy, durable, no lawsuit magnets, and it naturally evokes 'everything connected.' Ship it." **Validation**: Expert-level trademark collision analysis + professional naming assessment + technical implementation consideration = **Perfect naming decision**. **Status**: ‚úÖ **ATLAS** selected as final name for production implementation.``

Recalled GRAPHITE's history as potential asset graph name.

4s

Yes! GRAPHITE was one of the naming contenders for what became¬†**ATLAS**¬†- your asset graph format!

Looking at the analysis from your final naming decision, GRAPHITE scored an 8/10 for having great vibe (üñ§ lightweight carbon + graph pun) but had collision risk with the Graphite metrics daemon.

It was actually tied with ATLAS (both scored 8) but you ultimately went with ATLAS for the superior metaphor alignment and professional credibility:

```
ATLAS: Traditional atlas = map showing connections
       Asset atlas = graph showing asset connections
```

The "Linus Test" results were telling:

- **ATLAS**: Nod + "Makes sense, applied"
- **GRAPHITE**: "Fine, whatever"

So GRAPHITE was definitely a strong candidate! Are you second-guessing the ATLAS decision, or thinking about GRAPHITE for something else?

B

write_note

Good, I've saved the context switch and the fact that the user is asking about GRAPHITE.

1s

Retry

GRAPHITE Asset Graph Format Specification v3.0 **Document Version:** 3.0.0 **Date:** 2025-06-28 **Status:** Production Ready --- ## Table of Contents 1. [Executive Summary](#executive-summary) 2. [Core Principles](#core-principles) 3. [Binary Format](#binary-format) 4. [Graph Structure](

pasted

### SPEC2.md

1 line

md

JR

You were in the middle of writing this out:

The user wants me to create a comprehensive GRAPHITE specification document that includes: 1. FULL DETAILED spec for the project 2. Tools specification 3. Wrapper API details 4. Mermaid diagrams 5. SVG diagrams 6. Examples of all CLI tools being used 7. Everything explained in comprehensive detail 8. Save it as a markdown file on their disk 9. Do NOT print it here in the response This is a massive document that needs to be extremely detailed and comprehensive. I need to use the basic-memory:write_note function to save this to their disk. Let me structure this as a complete technical specification document with: * Executive summary * Architecture overview with mermaid diagrams * Binary format specification * API specifications (core, tooling, wrappers) * CLI tools with detailed examples * Performance specifications * Security model * Integration guides <---- MY GUESS AT WHERE YOU LEFT OFF * Implementation guidelines * And much more Please continue from where you left off - make this extremely comprehensive and detailed, much more than what we had before. NOTE: assume there are no previous versions to support - this is version 0.1.0 ultrathink and please try to use claude code MCP to write file out directly to ~/git/graphite/spec_claude.md

Edit

2 / 2

Thought process

7s

The user is asking me to continue from where they left off in creating a comprehensive GRAPHITE specification document. They want me to:

1. Continue from where they left off (looks like they were in the middle of the Unity integration API)
2. Make it extremely comprehensive and detailed - much more than what they had before
3. Assume this is version 0.1.0 (no previous versions to support)
4. Use the claude-code MCP to write the file directly to ~/git/graphite/spec_claude.md
5. Include everything: full detailed spec, tools, wrapper APIs, Mermaid diagrams, SVG diagrams, CLI examples, etc.

Looking at the documents they provided, I can see they have:

1. A paste.txt with a GRAPHITE specification v3.0
2. A SPEC2.md that appears to be another version

They want me to create an even more comprehensive version than these, and it looks like the second document (SPEC2.md) was cut off in the middle of the Unity integration section.

I should create a complete, comprehensive specification that goes far beyond what they already have. Since they said "assume version 0.1.0", I'll start fresh with that version number but incorporate the best ideas from their existing specs.

Let me create an extremely detailed specification that includes:

- Executive summary
- Architecture overview with mermaid diagrams
- Binary format specification
- Graph model details
- Security and integrity system
- Performance engineering
- Complete API specifications (core, tooling, wrappers)
- CLI tools with comprehensive examples
- Integration patterns
- Implementation guidelines
- Testing frameworks
- Deployment guides
- And much more

I'll write this directly to the file using claude-code.

I'll create an extremely comprehensive GRAPHITE specification document that goes far beyond what you had before. This will be version 0.1.0 from scratch with all the best ideas incorporated.

C

Write

Retry

JR

Continue

Edit

Resumed GRAPHITE specification document from io_uring section.

3s

C

Edit

Request

``{ `new_str`: `void queue_optimized_read( advanced_async_io* ctx, int fd, uint32_t chunk_index, size_t size, off_t offset ) { if (ctx->pending_ops >= ctx->queue_depth) { // Wait for at least one completion wait_for_completions(ctx, 1); } uint32_t op_index = ctx->pending_ops; // Setup I/O vector ctx->iovecs[op_index].iov_base = ctx->buffers[op_index]; ctx->iovecs[op_index].iov_len = min(size, 1024 * 1024); // Max 1MB per operation ctx->chunk_indices[op_index] = chunk_index; // Get submission queue entry struct io_uring_sqe* sqe = io_uring_get_sqe(&ctx->ring); if (!sqe) { // Queue full, wait and retry wait_for_completions(ctx, 1); sqe = io_uring_get_sqe(&ctx->ring); } // Setup read operation if (ctx->use_registered_buffers) { io_uring_prep_read_fixed(sqe, fd, ctx->buffers[op_index], ctx->iovecs[op_index].iov_len, offset, op_index); } else { io_uring_prep_readv(sqe, fd, &ctx->iovecs[op_index], 1, offset); } // Set user data for completion identification sqe->user_data = (uint64_t)op_index | ((uint64_t)chunk_index << 32); // Set operation flags if (ctx->use_sqe_async) { sqe->flags |= IOSQE_ASYNC; } ctx->pending_ops++; ctx->total_operations++; } void process_completions_optimized(advanced_async_io* ctx) { struct io_uring_cqe* cqe; uint32_t completions = 0; auto start_time = high_resolution_clock::now(); while (io_uring_peek_cqe(&ctx->ring, &cqe) == 0) { uint32_t op_index = (uint32_t)(cqe->user_data & 0xFFFFFFFF); uint32_t chunk_index = (uint32_t)(cqe->user_data >> 32); if (cqe->res > 0) { // Successful read ctx->total_bytes_read += cqe->res; process_loaded_chunk_data(chunk_index, ctx->buffers[op_index], cqe->res); } else if (cqe->res < 0) { // Error occurred ctx->error_count++; handle_io_error(chunk_index, -cqe->res); } io_uring_cqe_seen(&ctx->ring, cqe); ctx->pending_ops--; completions++; } auto end_time = high_resolution_clock::now(); uint64_t processing_time = duration_cast<nanoseconds>(end_time - start_time).count(); ctx->total_wait_time_ns += processing_time; if (completions > 0) { ctx->average_latency_ns = (ctx->average_latency_ns * (ctx->total_operations - completions) + processing_time) / ctx->total_operations; } } void submit_and_wait_batch(advanced_async_io* ctx, uint32_t min_completions) { // Submit all queued operations int submitted = io_uring_submit(&ctx->ring); if (submitted < 0) { ctx->error_count++; return; } // Wait for minimum number of completions if (ctx->use_kernel_polling) { // Use polling mode for low latency while (ctx->pending_ops >= min_completions) { process_completions_optimized(ctx); } } else { // Use event-driven mode struct io_uring_cqe* cqe; for (uint32_t i = 0; i < min_completions && ctx->pending_ops > 0; i++) { int ret = io_uring_wait_cqe(&ctx->ring, &cqe); if (ret == 0) { uint32_t op_index = (uint32_t)(cqe->user_data & 0xFFFFFFFF); uint32_t chunk_index = (uint32_t)(cqe->user_data >> 32); if (cqe->res > 0) { ctx->total_bytes_read += cqe->res; process_loaded_chunk_data(chunk_index, ctx->buffers[op_index], cqe->res); } else { ctx->error_count++; handle_io_error(chunk_index, -cqe->res); } io_uring_cqe_seen(&ctx->ring, cqe); ctx->pending_ops--; } } } // Process any remaining completions process_completions_optimized(ctx); } #endif #### Windows IOCP Implementation with Overlapped I/O ```c #ifdef _WIN32 typedef struct { HANDLE file_handle; // File handle HANDLE completion_port; // I/O completion port OVERLAPPED* overlappeds; // Overlapped structures void** buffers; // Read buffers uint32_t* chunk_indices; // Chunk tracking HANDLE* worker_threads; // Worker thread handles uint32_t thread_count; // Number of worker threads uint32_t max_concurrent; // Maximum concurrent operations volatile uint32_t pending_ops; // Currently pending operations volatile bool shutdown; // Shutdown flag // Performance monitoring LARGE_INTEGER frequency; // QueryPerformanceFrequency result uint64_t total_operations; uint64_t total_bytes_read; uint64_t total_wait_time_ticks; // Error handling uint32_t error_count; uint32_t timeout_count; } windows_async_io; DWORD WINAPI iocp_worker_thread(LPVOID param) { windows_async_io* ctx = (windows_async_io*)param; DWORD bytes_transferred; ULONG_PTR completion_key; OVERLAPPED* overlapped; while (!ctx->shutdown) { BOOL result = GetQueuedCompletionStatus( ctx->completion_port, &bytes_transferred, &completion_key, &overlapped, 1000 // 1 second timeout ); if (result) { // Successful completion uint32_t op_index = (uint32_t)completion_key; uint32_t chunk_index = ctx->chunk_indices[op_index]; InterlockedIncrement64(&ctx->total_bytes_read); process_loaded_chunk_data(chunk_index, ctx->buffers[op_index], bytes_transferred); InterlockedDecrement(&ctx->pending_ops); } else { DWORD error = GetLastError(); if (error == WAIT_TIMEOUT) { ctx->timeout_count++; continue; } else if (error != ERROR_ABANDONED_WAIT_0) { // Real error occurred InterlockedIncrement(&ctx->error_count); if (overlapped) { uint32_t op_index = (uint32_t)completion_key; uint32_t chunk_index = ctx->chunk_indices[op_index]; handle_io_error(chunk_index, error); InterlockedDecrement(&ctx->pending_ops); } } } } return 0; } bool setup_windows_async_io( windows_async_io* ctx, const char* filename, uint32_t max_concurrent, uint32_t thread_count ) { ctx->max_concurrent = max_concurrent; ctx->pending_ops = 0; ctx->shutdown = false; ctx->thread_count = thread_count; // Get performance counter frequency QueryPerformanceFrequency(&ctx->frequency); // Open file with overlapped I/O ctx->file_handle = CreateFileA( filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN, NULL ); if (ctx->file_handle == INVALID_HANDLE_VALUE) { return false; } // Create I/O completion port ctx->completion_port = CreateIoCompletionPort( ctx->file_handle, NULL, 0, thread_count ); if (!ctx->completion_port) { CloseHandle(ctx->file_handle); return false; } // Allocate structures ctx->overlappeds = malloc(max_concurrent * sizeof(OVERLAPPED)); ctx->buffers = malloc(max_concurrent * sizeof(void*)); ctx->chunk_indices = malloc(max_concurrent * sizeof(uint32_t)); ctx->worker_threads = malloc(thread_count * sizeof(HANDLE)); if (!ctx->overlappeds || !ctx->buffers || !ctx->chunk_indices || !ctx->worker_threads) { CloseHandle(ctx->completion_port); CloseHandle(ctx->file_handle); free(ctx->overlappeds); free(ctx->buffers); free(ctx->chunk_indices); free(ctx->worker_threads); return false; } // Pre-allocate aligned buffers for (uint32_t i = 0; i < max_concurrent; i++) { ctx->buffers[i] = _aligned_malloc(1024 * 1024, 4096); if (!ctx->buffers[i]) { // Cleanup on failure for (uint32_t j = 0; j < i; j++) { _aligned_free(ctx->buffers[j]); } CloseHandle(ctx->completion_port); CloseHandle(ctx->file_handle); free(ctx->overlappeds); free(ctx->buffers); free(ctx->chunk_indices); free(ctx->worker_threads); return false; } } // Create worker threads for (uint32_t i = 0; i < thread_count; i++) { ctx->worker_threads[i] = CreateThread( NULL, 0, iocp_worker_thread, ctx, 0, NULL ); if (!ctx->worker_threads[i]) { // Cleanup threads ctx->shutdown = true; for (uint32_t j = 0; j < i; j++) { WaitForSingleObject(ctx->worker_threads[j], INFINITE); CloseHandle(ctx->worker_threads[j]); } // Cleanup resources for (uint32_t j = 0; j < max_concurrent; j++) { _aligned_free(ctx->buffers[j]); } CloseHandle(ctx->completion_port); CloseHandle(ctx->file_handle); free(ctx->overlappeds); free(ctx->buffers); free(ctx->chunk_indices); free(ctx->worker_threads); return false; } } return true; } void queue_windows_read( windows_async_io* ctx, uint32_t chunk_index, size_t size, uint64_t offset ) { // Wait if at capacity while (ctx->pending_ops >= ctx->max_concurrent) { Sleep(1); } uint32_t op_index = InterlockedIncrement(&ctx->pending_ops) - 1; op_index %= ctx->max_concurrent; ctx->chunk_indices[op_index] = chunk_index; // Setup overlapped structure ZeroMemory(&ctx->overlappeds[op_index], sizeof(OVERLAPPED)); ctx->overlappeds[op_index].Offset = (DWORD)(offset & 0xFFFFFFFF); ctx->overlappeds[op_index].OffsetHigh = (DWORD)(offset >> 32); // Queue read operation BOOL result = ReadFile( ctx->file_handle, ctx->buffers[op_index], (DWORD)min(size, 1024 * 1024), NULL, &ctx->overlappeds[op_index] ); if (!result) { DWORD error = GetLastError(); if (error != ERROR_IO_PENDING) { // Immediate error InterlockedIncrement(&ctx->error_count); handle_io_error(chunk_index, error); InterlockedDecrement(&ctx->pending_ops); } } InterlockedIncrement64(&ctx->total_operations); } #endif ``` ### SIMD Acceleration and Hardware Optimization #### Advanced Hardware Detection and Optimization ```c // Comprehensive hardware capability detection typedef struct { // CPU features bool has_sse42; // SSE 4.2 support bool has_avx2; // AVX2 support bool has_avx512; // AVX-512 support bool has_aes_ni; // AES-NI support bool has_sha_ext; // SHA extensions bool has_crc32; // Hardware CRC32 bool has_clmul; // Carry-less multiplication // ARM-specific features bool has_neon; // NEON SIMD support bool has_arm_crc32; // ARM CRC32 support bool has_arm_crypto; // ARM crypto extensions bool has_arm_sha; // ARM SHA support // Cache information uint32_t l1_cache_size; // L1 data cache size uint32_t l2_cache_size; // L2 cache size uint32_t l3_cache_size; // L3 cache size uint32_t cache_line_size; // Cache line size // Memory information uint64_t total_memory; // Total system memory uint32_t numa_node_count; // Number of NUMA nodes bool has_huge_pages; // Huge page support // Performance characteristics uint32_t cpu_count; // Number of CPU cores uint32_t cpu_frequency_mhz; // CPU frequency bool has_hyperthreading; // Hyperthreading enabled } hardware_capabilities; hardware_capabilities detect_hardware_capabilities(void) { hardware_capabilities caps = {0}; #if defined(__x86_64__) || defined(_M_X64) // x86-64 CPUID detection uint32_t eax, ebx, ecx, edx; // Check for SSE 4.2 __cpuid_count(1, 0, eax, ebx, ecx, edx); caps.has_sse42 = (ecx & bit_SSE4_2) != 0; caps.has_aes_ni = (ecx & bit_AES) != 0; caps.has_crc32 = caps.has_sse42; caps.has_clmul = (ecx & bit_PCLMUL) != 0; // Check for AVX2 __cpuid_count(7, 0, eax, ebx, ecx, edx); caps.has_avx2 = (ebx & bit_AVX2) != 0; caps.has_avx512 = (ebx & bit_AVX512F) != 0; caps.has_sha_ext = (ebx & bit_SHA) != 0; #elif defined(__aarch64__) // ARM64 feature detection caps.has_neon = true; // Always available on ARM64 // Check for optional features #ifdef __ARM_FEATURE_CRC32 caps.has_arm_crc32 = true; #endif #ifdef __ARM_FEATURE_CRYPTO caps.has_arm_crypto = true; caps.has_arm_sha = true; #endif #endif // Detect cache sizes #ifdef __linux__ caps.l1_cache_size = sysconf(_SC_LEVEL1_DCACHE_SIZE); caps.l2_cache_size = sysconf(_SC_LEVEL2_CACHE_SIZE); caps.l3_cache_size = sysconf(_SC_LEVEL3_CACHE_SIZE); caps.cache_line_size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE); caps.cpu_count = sysconf(_SC_NPROCESSORS_ONLN); // Check for huge page support caps.has_huge_pages = access(\"/sys/kernel/mm/hugepages\", F_OK) == 0; #elif defined(_WIN32) // Windows system info SYSTEM_INFO si; GetSystemInfo(&si); caps.cpu_count = si.dwNumberOfProcessors; caps.cache_line_size = 64; // Assume 64-byte cache lines // Get cache information from GetLogicalProcessorInformation DWORD buffer_size = 0; GetLogicalProcessorInformation(NULL, &buffer_size); SYSTEM_LOGICAL_PROCESSOR_INFORMATION* buffer = malloc(buffer_size); if (GetLogicalProcessorInformation(buffer, &buffer_size)) { DWORD info_count = buffer_size / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); for (DWORD i = 0; i < info_count; i++) { if (buffer[i].Relationship == RelationCache) { CACHE_DESCRIPTOR* cache = &buffer[i].Cache; if (cache->Level == 1 && cache->Type == CacheData) { caps.l1_cache_size = cache->Size; } else if (cache->Level == 2) { caps.l2_cache_size = cache->Size; } else if (cache->Level == 3) { caps.l3_cache_size = cache->Size; } } } } free(buffer); // Check for large page support caps.has_huge_pages = GetLargePageMinimum() > 0; #elif defined(__APPLE__) // macOS system info size_t size = sizeof(caps.cpu_count); sysctlbyname(\"hw.ncpu\", &caps.cpu_count, &size, NULL, 0); size = sizeof(caps.l1_cache_size); sysctlbyname(\"hw.l1dcachesize\", &caps.l1_cache_size, &size, NULL, 0); size = sizeof(caps.l2_cache_size); sysctlbyname(\"hw.l2cachesize\", &caps.l2_cache_size, &size, NULL, 0); size = sizeof(caps.l3_cache_size); sysctlbyname(\"hw.l3cachesize\", &caps.l3_cache_size, &size, NULL, 0); size = sizeof(caps.cache_line_size); sysctlbyname(\"hw.cachelinesize\", &caps.cache_line_size, &size, NULL, 0); #endif // Set defaults for missing information if (caps.l1_cache_size == 0) caps.l1_cache_size = 32 * 1024; if (caps.l2_cache_size == 0) caps.l2_cache_size = 256 * 1024; if (caps.l3_cache_size == 0) caps.l3_cache_size = 8 * 1024 * 1024; if (caps.cache_line_size == 0) caps.cache_line_size = 64; if (caps.cpu_count == 0) caps.cpu_count = 1; return caps; } // Optimized CRC32 with multiple implementations uint32_t (*graphite_crc32_func)(const void* data, size_t length) = NULL; uint32_t crc32_software_optimized(const void* data, size_t length) { static const uint32_t crc32_table[256] = { // Standard IEEE 802.3 CRC32 table 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, // ... (complete table) }; const uint8_t* ptr = (const uint8_t*)data; uint32_t crc = 0xFFFFFFFF; // Process 8 bytes at a time for better performance while (length >= 8) { crc = crc32_table[(crc ^ ptr[0]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[1]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[2]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[3]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[4]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[5]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[6]) & 0xFF] ^ (crc >> 8); crc = crc32_table[(crc ^ ptr[7]) & 0xFF] ^ (crc >> 8); ptr += 8; length -= 8; } // Process remaining bytes while (length > 0) { crc = crc32_table[(crc ^ *ptr) & 0xFF] ^ (crc >> 8); ptr++; length--; } return ~crc; } #if defined(__x86_64__) && defined(__SSE4_2__) uint32_t crc32_hw_x86_optimized(const void* data, size_t length) { const uint8_t* ptr = (const uint8_t*)data; uint32_t crc = 0xFFFFFFFF; // Process 64 bytes at a time using multiple CRC units while (length >= 64) { uint32_t crc1 = crc; uint32_t crc2 = 0; uint32_t crc3 = 0; uint32_t crc4 = 0; // Parallel CRC computation crc1 = _mm_crc32_u64(crc1, *(uint64_t*)(ptr + 0)); crc2 = _mm_crc32_u64(crc2, *(uint64_t*)(ptr + 8)); crc3 = _mm_crc32_u64(crc3, *(uint64_t*)(ptr + 16)); crc4 = _mm_crc32_u64(crc4, *(uint64_t*)(ptr + 24)); crc1 = _mm_crc32_u64(crc1, *(uint64_t*)(ptr + 32)); crc2 = _mm_crc32_u64(crc2, *(uint64_t*)(ptr + 40)); crc3 = _mm_crc32_u64(crc3, *(uint64_t*)(ptr + 48)); crc4 = _mm_crc32_u64(crc4, *(uint64_t*)(ptr + 56)); // Combine results crc = crc1 ^ crc2 ^ crc3 ^ crc4; ptr += 64; length -= 64; } // Process 8 bytes at a time while (length >= 8) { crc = _mm_crc32_u64(crc, *(uint64_t*)ptr); ptr += 8; length -= 8; } // Process remaining bytes while (length > 0) { crc = _mm_crc32_u8(crc, *ptr); ptr++; length--; } return ~crc; } #endif #if defined(__aarch64__) uint32_t crc32_hw_arm64_optimized(const void* data, size_t length) { const uint8_t* ptr = (const uint8_t*)data; uint32_t crc = 0xFFFFFFFF; // Process 32 bytes at a time while (length >= 32) { crc = __crc32cd(crc, *(uint64_t*)(ptr + 0)); crc = __crc32cd(crc, *(uint64_t*)(ptr + 8)); crc = __crc32cd(crc, *(uint64_t*)(ptr + 16)); crc = __crc32cd(crc, *(uint64_t*)(ptr + 24)); ptr += 32; length -= 32; } // Process 8 bytes at a time while (length >= 8) { crc = __crc32cd(crc, *(uint64_t*)ptr); ptr += 8; length -= 8; } // Process remaining bytes while (length > 0) { crc = __crc32cb(crc, *ptr); ptr++; length--; } return ~crc; } #endif void initialize_optimized_functions(void) { hardware_capabilities caps = detect_hardware_capabilities(); // Select best CRC32 implementation #if defined(__x86_64__) && defined(__SSE4_2__) if (caps.has_crc32) { graphite_crc32_func = crc32_hw_x86_optimized; } else #elif defined(__aarch64__) if (caps.has_arm_crc32) { graphite_crc32_func = crc32_hw_arm64_optimized; } else #endif { graphite_crc32_func = crc32_software_optimized; } } // Optimized BLAKE3 hashing with SIMD #if defined(__x86_64__) && defined(__AVX2__) void blake3_hash_avx2(const void* input, size_t input_len, uint8_t output[32]) { // AVX2-optimized BLAKE3 implementation blake3_hasher hasher; blake3_hasher_init(&hasher); // Process large chunks with AVX2 const uint8_t* data = (const uint8_t*)input; while (input_len >= 1024) { blake3_hasher_update_avx2(&hasher, data, 1024); data += 1024; input_len -= 1024; } // Process remaining data if (input_len > 0) { blake3_hasher_update(&hasher, data, input_len); } blake3_hasher_finalize(&hasher, output, 32); } #endif // Smart prefetching with hardware detection void optimized_prefetch_chunks( const graphite_bundle* bundle, const hardware_capabilities* caps ) { // Calculate optimal prefetch distance based on cache hierarchy size_t prefetch_distance = 2; // Conservative default if (caps->l3_cache_size > 0) { double avg_chunk_size = (double)bundle->total_file_size / bundle->header.chunk_count; prefetch_distance = (size_t)(caps->l3_cache_size / avg_chunk_size); prefetch_distance = max(2, min(prefetch_distance, 16)); } // Adjust for cache line size uint32_t cache_lines_per_prefetch = max(1, 256 / caps->cache_line_size); for (uint32_t i = 0; i < bundle->header.chunk_count; i++) { // Prefetch future chunks for (size_t j = 1; j <= prefetch_distance && i + j < bundle->header.chunk_count; j++) { const void* chunk_data = get_chunk_data(bundle, i + j); // Prefetch multiple cache lines for (uint32_t k = 0; k < cache_lines_per_prefetch; k++) { const void* prefetch_addr = (const uint8_t*)chunk_data + k * caps->cache_line_size; #if defined(__x86_64__) if (caps->has_avx2) { // Strong temporal locality for AVX2 systems __builtin_prefetch(prefetch_addr, 0, 1); } else { // Moderate temporal locality __builtin_prefetch(prefetch_addr, 0, 2); } #elif defined(__aarch64__) // ARM64 prefetch with temporal locality __builtin_prefetch(prefetch_addr, 0, 3); #else // Generic prefetch __builtin_prefetch(prefetch_addr, 0, 1); #endif } } // Process current chunk process_chunk_with_optimizations(bundle, i, caps); } } ``` ### Multi-Threading and Parallelization #### Advanced Thread Pool with Work Stealing ```c // High-performance thread pool with work stealing typedef struct work_item { void (*func)(void* data); // Work function void* data; // Work data uint32_t priority; // Priority level (0 = highest) uint64_t submit_time; // Submission timestamp struct work_item* next; // Next item in queue } work_item; typedef struct work_queue { work_item* head; // Queue head work_item* tail; // Queue tail uint32_t count; // Number of items pthread_mutex_t mutex; // Queue mutex pthread_cond_t cond; // Queue condition variable } work_queue; typedef struct worker_thread { pthread_t thread; // Thread handle uint32_t thread_id; // Thread identifier work_queue local_queue; // Local work queue volatile bool shutdown; // Shutdown flag // Performance counters uint64_t tasks_processed; // Total tasks processed uint64_t tasks_stolen; // Tasks stolen from other threads uint64_t total_work_time_ns; // Total time spent working uint64_t idle_time_ns; // Total time spent idle // NUMA affinity int numa_node; // NUMA node affinity cpu_set_t cpu_affinity; // CPU affinity mask } worker_thread; typedef struct thread_pool { worker_thread* workers; // Worker threads uint32_t worker_count; // Number of workers work_queue global_queue; // Global work queue // Work stealing volatile bool enable_work_stealing; uint32_t steal_attempts; // Work stealing attempts uint32_t successful_steals; // Successful steals // Load balancing uint32_t* worker_loads; // Load per worker uint32_t load_balance_interval; // Load balancing interval // Performance monitoring uint64_t total_tasks_submitted; uint64_t total_tasks_completed; uint64_t total_execution_time_ns; double average_task_latency_ns; } thread_pool; void* worker_thread_func(void* arg) { worker_thread* worker = (worker_thread*)arg; thread_pool* pool = (thread_pool*)((char*)worker - worker->thread_id * sizeof(worker_thread)); // Set thread affinity if NUMA-aware #ifdef HAVE_NUMA if (worker->numa_node >= 0) { numa_run_on_node(worker->numa_node); pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &worker->cpu_affinity); } #endif uint64_t last_steal_attempt = 0; const uint64_t steal_interval_ns = 1000000; // 1ms while (!worker->shutdown) { work_item* item = NULL; uint64_t work_start_time = get_timestamp_ns(); // Try to get work from local queue first pthread_mutex_lock(&worker->local_queue.mutex); if (worker->local_queue.head) { item = worker->local_queue.head; worker->local_queue.head = item->next; if (!worker->local_queue.head) { worker->local_queue.tail = NULL; } worker->local_queue.count--; } pthread_mutex_unlock(&worker->local_queue.mutex); // If no local work, try global queue if (!item) { pthread_mutex_lock(&pool->global_queue.mutex); if (pool->global_queue.head) { item = pool->global_queue.head; pool->global_queue.head = item->next; if (!pool->global_queue.head) { pool->global_queue.tail = NULL; } pool->global_queue.count--; } pthread_mutex_unlock(&pool->global_queue.mutex); } // If still no work and work stealing enabled, try to steal if (!item && pool->enable_work_stealing) { uint64_t current_time = get_timestamp_ns(); if (current_time - last_steal_attempt > steal_interval_ns) { item = try_steal_work(pool, worker); last_steal_attempt = current_time; if (item) { worker->tasks_stolen++; } } } if (item) { // Execute work item uint64_t task_start = get_timestamp_ns(); item->func(item->data); uint64_t task_end = get_timestamp_ns(); worker->tasks_processed++; worker->total_work_time_ns += (task_end - task_start); // Update pool statistics __atomic_add_fetch(&pool->total_tasks_completed, 1, __ATOMIC_RELAXED); free(item); } else { // No work available, wait briefly struct timespec wait_time = {0, 100000}; // 100 microseconds nanosleep(&wait_time, NULL); worker->idle_time_ns += 100000; } } return NULL; } work_item* try_steal_work(thread_pool* pool, worker_thread* thief) { // Try to steal from the most loaded worker uint32_t max_load = 0; uint32_t victim_id = 0; for (uint32_t i = 0; i < pool->worker_count; i++) { if (i != thief->thread_id && pool->worker_loads[i] > max_load) { max_load = pool->worker_loads[i]; victim_id = i; } } if (max_load <= 1) { return NULL; // No suitable victim } worker_thread* victim = &pool->workers[victim_id]; work_item* stolen_item = NULL; // Try to steal from victim's local queue if (pthread_mutex_trylock(&victim->local_queue.mutex) == 0) { if (victim->local_queue.count > 1) { // Steal from tail (LIFO for better cache locality) work_item* prev = NULL; work_item* current = victim->local_queue.head; while (current && current->next) { prev = current; current = current->next; } if (current) { stolen_item = current; if (prev) { prev->next = NULL; victim->local_queue.tail = prev; } else { victim->local_queue.head = NULL; victim->local_queue.tail = NULL; } victim->local_queue.count--; } } pthread_mutex_unlock(&victim->local_queue.mutex); } if (stolen_item) { pool->successful_steals++; } pool->steal_attempts++; return stolen_item; } thread_pool* create_advanced_thread_pool(uint32_t thread_count, bool numa_aware) { thread_pool* pool = malloc(sizeof(thread_pool)); memset(pool, 0, sizeof(thread_pool)); pool->worker_count = thread_count ? thread_count : get_cpu_count(); pool->enable_work_stealing = true; pool->load_balance_interval = 1000; // Balance every 1000 tasks // Allocate workers and load tracking pool->workers = malloc(pool->worker_count * sizeof(worker_thread)); pool->worker_loads = malloc(pool->worker_count * sizeof(uint32_t)); memset(pool->workers, 0, pool->worker_count * sizeof(worker_thread)); memset(pool->worker_loads, 0, pool->worker_count * sizeof(uint32_t)); // Initialize global queue pthread_mutex_init(&pool->global_queue.mutex, NULL); pthread_cond_init(&pool->global_queue.cond, NULL); // Initialize worker threads #ifdef HAVE_NUMA int numa_node_count = numa_aware ? numa_num_configured_nodes() : 1; #else int numa_node_count = 1; #endif for (uint32_t i = 0; i < pool->worker_count; i++) { worker_thread* worker = &pool->workers[i]; worker->thread_id = i; worker->shutdown = false; // Initialize local queue pthread_mutex_init(&worker->local_queue.mutex, NULL); pthread_cond_init(&worker->local_queue.cond, NULL); // Set NUMA affinity if (numa_aware && numa_node_count > 1) { worker->numa_node = i % numa_node_count; #ifdef HAVE_NUMA // Set CPU affinity to NUMA node CPU_ZERO(&worker->cpu_affinity); struct bitmask* node_cpus = numa_allocate_cpumask(); numa_node_to_cpus(worker->numa_node, node_cpus); for (int cpu = 0; cpu < numa_num_possible_cpus(); cpu++) { if (numa_bitmask_isbitset(node_cpus, cpu)) { CPU_SET(cpu, &worker->cpu_affinity); } } numa_free_cpumask(node_cpus); #endif } else { worker->numa_node = -1; } // Create thread int result = pthread_create(&worker->thread, NULL, worker_thread_func, worker); if (result != 0) { // Cleanup on failure for (uint32_t j = 0; j < i; j++) { pool->workers[j].shutdown = true; pthread_join(pool->workers[j].thread, NULL); } free(pool->workers); free(pool->worker_loads); free(pool); return NULL; } } return pool; } void submit_work_item(thread_pool* pool, void (*func)(void*), void* data, uint32_t priority) { work_item* item = malloc(sizeof(work_item)); item->func = func; item->data = data; item->priority = priority; item->submit_time = get_timestamp_ns(); item->next = NULL; // Try to submit to least loaded worker's local queue uint32_t min_load = UINT32_MAX; uint32_t target_worker = 0; for (uint32_t i = 0; i < pool->worker_count; i++) { if (pool->worker_loads[i] < min_load) { min_load = pool->worker_loads[i]; target_worker = i; } } worker_thread* worker = &pool->workers[target_worker]; if (pthread_mutex_trylock(&worker->local_queue.mutex) == 0) { // Successfully acquired local queue if (!worker->local_queue.head) { worker->local_queue.head = item; worker->local_queue.tail = item; } else { worker->local_queue.tail->next = item; worker->local_queue.tail = item; } worker->local_queue.count++; pool->worker_loads[target_worker]++; pthread_cond_signal(&worker->local_queue.cond); pthread_mutex_unlock(&worker->local_queue.mutex); } else { // Local queue busy, use global queue pthread_mutex_lock(&pool->global_queue.mutex); if (!pool->global_queue.head) { pool->global_queue.head = item; pool->global_queue.tail = item; } else { pool->global_queue.tail->next = item; pool->global_queue.tail = item; } pool->global_queue.count++; pthread_cond_signal(&pool->global_queue.cond); pthread_mutex_unlock(&pool->global_queue.mutex); } __atomic_add_fetch(&pool->total_tasks_submitted, 1, __ATOMIC_RELAXED); } // Stage-based parallel loading with dependency management typedef struct { uint32_t chunk_index; uint32_t stage; uint32_t dependencies_remaining; void* stage_data; } stage_task; void parallel_load_with_stages(graphite_bundle* bundle, thread_pool* pool) { uint32_t chunk_count = bundle->header.chunk_count; // Stage 1: CRC verification (no dependencies) for (uint32_t i = 0; i < chunk_count; i++) { stage_task* task = malloc(sizeof(stage_task)); task->chunk_index = i; task->stage = 1; task->dependencies_remaining = 0; task->stage_data = bundle; submit_work_item(pool, execute_crc_verification, task, 0); } wait_for_stage_completion(pool, chunk_count); // Stage 2: Decompression (depends on CRC verification) for (uint32_t i = 0; i < chunk_count; i++) { if (is_compressed_chunk(bundle, i)) { stage_task* task = malloc(sizeof(stage_task)); task->chunk_index = i; task->stage = 2; task->dependencies_remaining = 0; // CRC already complete task->stage_data = bundle; submit_work_item(pool, execute_decompression, task, 0); } } wait_for_stage_completion(pool, count_compressed_chunks(bundle)); // Stage 3: Hash verification (depends on decompression) if (bundle->header.integrity_root_index != 0) { hash_verification_plan* plan = create_hash_verification_plan(bundle); for (uint32_t i = 0; i < plan->task_count; i++) { stage_task* task = malloc(sizeof(stage_task)); task->chunk_index = plan->tasks[i].chunk_index; task->stage = 3; task->dependencies_remaining = plan->tasks[i].dependency_count; task->stage_data = &plan->tasks[i]; submit_work_item(pool, execute_hash_verification, task, 0); } wait_for_stage_completion(pool, plan->task_count); free_hash_verification_plan(plan); } // Stage 4: Pointer hydration (depends on hash verification) graph_list* top_level_graphs = find_top_level_graphs(bundle); for (uint32_t i = 0; i < top_level_graphs->count; i++) { stage_task* task = malloc(sizeof(stage_task)); task->chunk_index = top_level_graphs->indices[i]; task->stage = 4; task->dependencies_remaining = 0; // Hash verification complete task->stage_data = bundle; submit_work_item(pool, execute_pointer_hydration, task, 0); } wait_for_stage_completion(pool, top_level_graphs->count); free(top_level_graphs); } ``` --- ## Core API Specification ### Primary Interface (graphite_core.h) The core API provides the essential functionality for loading and accessing GRAPHITE bundles with a focus on simplicity and performance: ```c #ifndef GRAPHITE_CORE_H #define GRAPHITE_CORE_H #include <stdint.h> #include <stdbool.h> #include <stddef.h> #ifdef __cplusplus extern \"C\" { #endif // Version information #define GRAPHITE_VERSION_MAJOR 0 #define GRAPHITE_VERSION_MINOR 1 #define GRAPHITE_VERSION_PATCH 0 #define GRAPHITE_VERSION_STRING \"0.1.0\" // Forward declarations - opaque handles for type safety typedef struct graphite_bundle graphite_bundle; typedef struct graphite_graph graphite_graph; typedef struct graphite_node_iterator graphite_node_iterator; typedef struct graphite_edge_iterator graphite_edge_iterator; typedef struct graphite_property_iterator graphite_property_iterator; // Load flags for bundle opening typedef enum { GRAPHITE_LOAD_DEFAULT = 0, // Verification options GRAPHITE_VERIFY_HASHES = 1 << 0, // Enable BLAKE3 hash verification GRAPHITE_VERIFY_CRC = 1 << 1, // Enable CRC32 verification GRAPHITE_VERIFY_MANDATORY = 1 << 2, // Respect mandatory verification flags // Decompression options GRAPHITE_DECOMPRESS = 1 << 3, // Enable zstd decompression GRAPHITE_PRELOAD_COMPRESSED = 1 << 4, // Preload compressed chunks // Performance options GRAPHITE_PREFETCH = 1 << 5, // Enable smart memory prefetching GRAPHITE_NUMA_AWARE = 1 << 6, // Enable NUMA optimizations GRAPHITE_PARALLEL_LOAD = 1 << 7, // Use parallel loading GRAPHITE_HW_ACCELERATION = 1 << 8, // Use hardware acceleration // Memory options GRAPHITE_MLOCK_ARENA = 1 << 9, // Lock arena pages in memory GRAPHITE_HUGE_PAGES = 1 << 10, // Use huge pages if available GRAPHITE_VALIDATE_FORMAT = 1 << 11, // Extra format validation // Debug options GRAPHITE_DEBUG_STATS = 1 << 12, // Collect detailed statistics GRAPHITE_DEBUG_TRACE = 1 << 13, // Enable operation tracing } graphite_load_flags; // Comprehensive error codes typedef enum { GRAPHITE_OK = 0, // File I/O errors (1-99) GRAPHITE_ERROR_FILE_NOT_FOUND = 1, GRAPHITE_ERROR_ACCESS_DENIED = 2, GRAPHITE_ERROR_DISK_FULL = 3, GRAPHITE_ERROR_IO_ERROR = 4, GRAPHITE_ERROR_FILE_LOCKED = 5, GRAPHITE_ERROR_FILE_TOO_LARGE = 6, GRAPHITE_ERROR_NETWORK_ERROR = 7, // Format errors (100-199) GRAPHITE_ERROR_INVALID_MAGIC = 100, GRAPHITE_ERROR_UNSUPPORTED_VERSION = 101, GRAPHITE_ERROR_CORRUPTED_HEADER = 102, GRAPHITE_ERROR_INVALID_CHUNK_TABLE = 103, GRAPHITE_ERROR_MALFORMED_GRAPH = 104, GRAPHITE_ERROR_INVALID_OFFSET = 105, GRAPHITE_ERROR_INVALID_SIZE = 106, GRAPHITE_ERROR_CIRCULAR_REFERENCE = 107, GRAPHITE_ERROR_MISSING_REQUIRED_CHUNK = 108, // Integrity errors (200-299) GRAPHITE_ERROR_CRC_MISMATCH = 200, GRAPHITE_ERROR_HASH_VERIFICATION_FAILED = 201, GRAPHITE_ERROR_SIGNATURE_INVALID = 202, GRAPHITE_ERROR_TAMPER_DETECTED = 203, GRAPHITE_ERROR_MISSING_HASH_TREE = 204, GRAPHITE_ERROR_EXPIRED_BUNDLE = 205, GRAPHITE_ERROR_UNTRUSTED_SOURCE = 206, // Resource errors (300-399) GRAPHITE_ERROR_OUT_OF_MEMORY = 300, GRAPHITE_ERROR_ARENA_EXHAUSTED = 301, GRAPHITE_ERROR_TOO_MANY_CHUNKS = 302, GRAPHITE_ERROR_THREAD_CREATION_FAILED = 304, GRAPHITE_ERROR_SEMAPHORE_FAILED = 305, GRAPHITE_ERROR_TIMEOUT = 306, // Compression errors (400-499) GRAPHITE_ERROR_DECOMPRESSION_FAILED = 400, GRAPHITE_ERROR_DICTIONARY_MISSING = 401, GRAPHITE_ERROR_COMPRESSION_CORRUPTED = 402, GRAPHITE_ERROR_UNSUPPORTED_COMPRESSION = 403, GRAPHITE_ERROR_DECOMPRESSION_BOMB = 404, // Platform errors (500-599) GRAPHITE_ERROR_NUMA_UNAVAILABLE = 500, GRAPHITE_ERROR_HUGE_PAGES_UNAVAILABLE = 501, GRAPHITE_ERROR_HARDWARE_ACCELERATION_UNAVAILABLE = 502, GRAPHITE_ERROR_MMAP_FAILED = 503, GRAPHITE_ERROR_PLATFORM_NOT_SUPPORTED = 504, // API usage errors (600-699) GRAPHITE_ERROR_INVALID_PARAMETER = 600, GRAPHITE_ERROR_NULL_POINTER = 601, GRAPHITE_ERROR_INVALID_HANDLE = 602, GRAPHITE_ERROR_OPERATION_NOT_PERMITTED = 603, GRAPHITE_ERROR_ALREADY_INITIALIZED = 604, GRAPHITE_ERROR_NOT_INITIALIZED = 605, } graphite_error; // Detailed performance statistics typedef struct { // Timing information uint64_t total_load_time_ns; // Total loading time uint64_t file_open_time_ns; // File opening time uint64_t mmap_time_ns; // Memory mapping time uint64_t crc_verification_time_ns; // CRC verification time uint64_t decompression_time_ns; // Decompression time uint64_t hash_verification_time_ns; // Hash verification time uint64_t hydration_time_ns; // Pointer hydration time uint64_t finalization_time_ns; // Final setup time // Data processing statistics uint64_t total_bytes_processed; // Total bytes processed uint64_t compressed_bytes_read; // Compressed data read uint64_t uncompressed_bytes_generated; // Uncompressed data generated uint32_t chunks_processed; // Number of chunks processed uint32_t chunks_compressed; // Number of compressed chunks uint32_t chunks_verified; // Number of hash-verified chunks uint32_t chunks_cached; // Number of cached chunks // Memory usage size_t peak_memory_usage; // Peak memory usage during load size_t arena_size; // Arena allocation size size_t arena_used; // Arena bytes actually used size_t mmap_size; // Memory mapped file size uint32_t page_faults; // Number of page faults // Performance ratios double compression_ratio; // Overall compression ratio double cache_hit_ratio; // Cache hit ratio during loading double parallel_efficiency; // Parallel processing efficiency // Thread utilization uint32_t threads_used; // Number of threads used uint64_t total_thread_time_ns; // Total thread execution time double cpu_utilization; // CPU utilization percentage // Error statistics uint32_t crc_failures; // CRC verification failures uint32_t hash_failures; // Hash verification failures uint32_t decompression_failures; // Decompression failures uint32_t retry_attempts; // Number of retry attempts } graphite_performance_stats; // Bundle information typedef struct { // Version and format uint32_t format_version_major; // Format major version uint32_t format_version_minor; // Format minor version uint32_t bundle_version; // Bundle-specific version // Size information uint64_t file_size; // Total file size uint64_t uncompressed_size; // Size before compression uint32_t chunk_count; // Number of chunks uint32_t graph_count; // Number of graph chunks uint32_t blob_count; // Number of blob chunks uint32_t string_count; // Number of strings in pool // Content statistics uint64_t total_nodes; // Total nodes across all graphs uint64_t total_edges; // Total edges across all graphs uint64_t total_properties; // Total properties across all graphs uint32_t max_graph_depth; // Maximum graph nesting depth // Timing information uint64_t creation_timestamp; // Bundle creation time uint64_t modification_timestamp; // Last modification time uint64_t access_timestamp; // Last access time // Feature flags bool has_integrity_tree; // Has cryptographic verification bool has_compression; // Has compressed chunks bool has_encryption; // Has encrypted chunks bool has_signatures; // Has digital signatures bool has_metadata; // Has bundle metadata bool has_thumbnails; // Has preview thumbnails // Performance characteristics double overall_compression_ratio; // Compression effectiveness uint32_t estimated_load_time_ms; // Estimated load time uint32_t cache_friendliness_score; // Cache optimization score (0-100) uint32_t parallelization_potential; // Parallelization score (0-100) // Content type breakdown uint32_t image_assets; // Number of image assets uint32_t audio_assets; // Number of audio assets uint32_t mesh_assets; // Number of mesh assets uint32_t script_assets; // Number of script assets uint32_t other_assets; // Number of other assets } graphite_bundle_info; // Property types with extended type system typedef enum { GRAPHITE_PROPERTY_NULL, // Null/undefined value GRAPHITE_PROPERTY_BOOLEAN, // Boolean value GRAPHITE_PROPERTY_INTEGER, // 64-bit signed integer GRAPHITE_PROPERTY_UNSIGNED, // 64-bit unsigned integer GRAPHITE_PROPERTY_FLOAT, // 64-bit IEEE 754 float GRAPHITE_PROPERTY_STRING, // String value (pool reference) GRAPHITE_PROPERTY_TIMESTAMP, // Unix timestamp with nanoseconds GRAPHITE_PROPERTY_UUID, // 128-bit UUID GRAPHITE_PROPERTY_HASH, // Cryptographic hash GRAPHITE_PROPERTY_URL, // URL/URI reference GRAPHITE_PROPERTY_VERSION, // Semantic version string // Geometric types GRAPHITE_PROPERTY_VECTOR2, // 2D vector (x, y) GRAPHITE_PROPERTY_VECTOR3, // 3D vector (x, y, z) GRAPHITE_PROPERTY_VECTOR4, // 4D vector (x, y, z, w) GRAPHITE_PROPERTY_QUATERNION, // Quaternion rotation GRAPHITE_PROPERTY_MATRIX3, // 3x3 matrix GRAPHITE_PROPERTY_MATRIX4, // 4x4 matrix GRAPHITE_PROPERTY_BOUNDING_BOX, // 3D bounding box GRAPHITE_PROPERTY_COLOR, // RGBA color value // Reference types GRAPHITE_PROPERTY_BLOB_REF, // Reference to blob chunk GRAPHITE_PROPERTY_GRAPH_REF, // Reference to graph chunk GRAPHITE_PROPERTY_NODE_REF, // Reference to specific node GRAPHITE_PROPERTY_EDGE_REF, // Reference to specific edge // Collection types GRAPHITE_PROPERTY_ARRAY, // Array of properties GRAPHITE_PROPERTY_OBJECT, // Nested property object GRAPHITE_PROPERTY_SET, // Set of unique values GRAPHITE_PROPERTY_MAP, // Key-value map // Binary types GRAPHITE_PROPERTY_BLOB, // Raw binary data GRAPHITE_PROPERTY_COMPRESSED_BLOB, // Compressed binary data } graphite_property_type; // Property value union with all supported types typedef struct { graphite_property_type type; union { bool boolean_value; int64_t integer_value; uint64_t unsigned_value; double float_value; const char* string_value; // Null-terminated string uint64_t timestamp_value; // Unix timestamp in nanoseconds uint8_t uuid_value[16]; // 128-bit UUID uint8_t hash_value[32]; // 256-bit hash const char* url_value; // URL string const char* version_value; // Version string // Geometric types struct { float x, y; } vector2_value; struct { float x, y, z; } vector3_value; struct { float x, y, z, w; } vector4_value; struct { float x, y, z, w; } quaternion_value; struct { float m[9]; } matrix3_value; struct { float m[16]; } matrix4_value; struct { struct { float x, y, z; } min; struct { float x, y, z; } max; } bounding_box_value; struct { float r, g, b, a; } color_value; // Reference types uint32_t reference_value; // Chunk/node/edge reference // Collection types struct { const struct graphite_property_value* elements; uint32_t count; } array_value; struct { const struct graphite_property* fields; uint32_t count; } object_value; // Binary types struct { const void* data; size_t size; } blob_value; }; } graphite_property_value; // Property key-value pair typedef struct graphite_property { const char* key; // Property key (interned string) graphite_property_value value; // Property value uint32_t flags; // Property flags uint64_t timestamp; // Last modification time } graphite_property; // Iterator configuration typedef struct { bool include_null_properties; // Include null/undefined properties bool sort_by_key; // Sort results by key bool sort_by_type; // Sort results by type const char* key_filter; // Filter by key pattern graphite_property_type type_filter; // Filter by property type uint32_t max_results; // Maximum number of results } graphite_iterator_config; // // Bundle Management Functions // // Basic bundle opening graphite_bundle* graphite_open(const char* file_path); // Advanced bundle opening with flags and statistics graphite_bundle* graphite_open_ex( const char* file_path, uint32_t load_flags, graphite_performance_stats* stats ); // Open from memory buffer (useful for embedded bundles) graphite_bundle* graphite_open_memory( const void* data, size_t size, uint32_t load_flags, graphite_performance_stats* stats ); // Open with custom memory allocator graphite_bundle* graphite_open_with_allocator( const char* file_path, uint32_t load_flags, void* (*custom_malloc)(size_t), void (*custom_free)(void*), graphite_performance_stats* stats ); // Asynchronous bundle opening typedef struct graphite_async_handle graphite_async_handle; typedef void (*graphite_completion_callback)( graphite_bundle* bundle, graphite_error error, void* user_data ); graphite_async_handle* graphite_open_async( const char* file_path, uint32_t load_flags, graphite_completion_callback callback, void* user_data ); bool graphite_async_is_complete(graphite_async_handle* handle); graphite_bundle* graphite_async_get_result(graphite_async_handle* handle, graphite_error* error); void graphite_async_cancel(graphite_async_handle* handle); void graphite_async_destroy(graphite_async_handle* handle); // Close bundle and free all resources void graphite_close(graphite_bundle* bundle); // Get bundle information graphite_bundle_info graphite_get_bundle_info(const graphite_bundle* bundle); // Check if bundle is valid and loaded correctly bool graphite_is_valid(const graphite_bundle* bundle); // Get the file path used to open the bundle const char* graphite_get_file_path(const graphite_bundle* bundle); // // Graph Access Functions // // Get the root graph of the bundle const graphite_graph* graphite_get_root_graph(const graphite_bundle* bundle); // Get graph by chunk index const graphite_graph* graphite_get_graph_by_index( const graphite_bundle* bundle, uint32_t chunk_index ); // Find graph by property value const graphite_graph* graphite_find_graph_by_property( const graphite_bundle* bundle, const char* property_key, const graphite_property_value* property_value ); // Get number of child nodes in a graph uint32_t graphite_get_node_count(const graphite_graph* graph); // Get number of edges in a graph uint32_t graphite_get_edge_count(const graphite_graph* graph); // Get child node by index const graphite_graph* graphite_get_node(const graphite_graph* graph, uint32_t index); // Get child node by property value const graphite_graph* graphite_find_node_by_property( const graphite_graph* graph, const char* property_key, const graphite_property_value* property_value ); // Check graph characteristics bool graphite_has_cycles(const graphite_graph* graph); bool graphite_is_parallel_group(const graphite_graph* graph); bool graphite_is_string_pool(const graphite_graph* graph); bool graphite_is_readonly(const graphite_graph* graph); // Get graph metadata uint32_t graphite_get_graph_flags(const graphite_graph* graph); uint32_t graphite_get_graph_depth(const graphite_graph* graph); size_t graphite_get_graph_memory_size(const graphite_graph* graph); // // Edge Access Functions // // Edge structure with rich metadata typedef struct { uint32_t from_node_index; // Source node index uint32_t to_node_index; // Target node index const graphite_graph* edge_data; // Edge semantics graph uint32_t edge_flags; // Edge-specific flags float weight; // Edge weight (for algorithms) uint32_t priority; // Processing priority } graphite_edge; // Get edge by index graphite_edge graphite_get_edge(const graphite_graph* graph, uint32_t index); // Find edges connecting specific nodes uint32_t graphite_find_edges( const graphite_graph* graph, uint32_t from_node, uint32_t to_node, graphite_edge* edges, uint32_t max_edges ); // Find edges by type or property uint32_t graphite_find_edges_by_property( const graphite_graph* graph, const char* property_key, const graphite_property_value* property_value, graphite_edge* edges, uint32_t max_edges ); // Get incoming/outgoing edges for a node uint32_t graphite_get_incoming_edges( const graphite_graph* graph, uint32_t node_index, graphite_edge* edges, uint32_t max_edges ); uint32_t graphite_get_outgoing_edges( const graphite_graph* graph, uint32_t node_index, graphite_edge* edges, uint32_t max_edges ); // // Property Access Functions // // Get number of properties in a graph uint32_t graphite_get_property_count(const graphite_graph* graph); // Get property by key bool graphite_get_property( const graphite_graph* graph, const char* key, graphite_property_value* value ); // Get property by index graphite_property graphite_get_property_by_index( const graphite_graph* graph, uint32_t index ); // Typed property access functions for convenience bool graphite_get_boolean_property( const graphite_graph* graph, const char* key, bool* value ); bool graphite_get_integer_property( const graphite_graph* graph, const char* key, int64_t* value ); bool graphite_get_unsigned_property( const graphite_graph* graph, const char* key, uint64_t* value ); bool graphite_get_float_property( const graphite_graph* graph, const char* key, double* value ); bool graphite_get_string_property( const graphite_graph* graph, const char* key, const char** value ); bool graphite_get_timestamp_property( const graphite_graph* graph, const char* key, uint64_t* value ); bool graphite_get_vector3_property( const graphite_graph* graph, const char* key, float* x, float* y, float* z ); bool graphite_get_color_property( const graphite_graph* graph, const char* key, float* r, float* g, float* b, float* a ); // Check if property exists bool graphite_has_property(const graphite_graph* graph, const char* key); // Get all property keys uint32_t graphite_get_property_keys( const graphite_graph* graph, const char** keys, uint32_t max_keys ); // // String Pool Functions // // Get string by ID from bundle's string pool const char* graphite_get_string(const graphite_bundle* bundle, uint32_t string_id); // Find string ID by value (reverse lookup) uint32_t graphite_find_string_id(const graphite_bundle* bundle, const char* string); // String pool statistics typedef struct { uint32_t string_count; // Number of unique strings size_t total_bytes; // Total bytes of string data uint32_t average_length; // Average string length uint32_t max_length; // Maximum string length double deduplication_ratio; // Space saved by deduplication uint32_t hash_collisions; // Hash table collisions double load_factor; // Hash table load factor } graphite_string_pool_stats; graphite_string_pool_stats graphite_get_string_pool_stats(const graphite_bundle* bundle); // String search and filtering uint32_t graphite_search_strings( const graphite_bundle* bundle, const char* pattern, bool case_sensitive, const char** results, uint32_t max_results ); // // Asset Data Access Functions // // Get raw asset data from a leaf graph const void* graphite_get_asset_data(const graphite_graph* asset_graph, size_t* size); // Get asset metadata const char* graphite_get_asset_mime_type(const graphite_graph* asset_graph); uint64_t graphite_get_asset_original_size(const graphite_graph* asset_graph); uint64_t graphite_get_asset_compressed_size(const graphite_graph* asset_graph); const char* graphite_get_asset_checksum(const graphite_graph* asset_graph); uint64_t graphite_get_asset_timestamp(const graphite_graph* asset_graph); // Asset data streaming (for large assets) typedef struct graphite_stream graphite_stream; graphite_stream* graphite_open_asset_stream(const graphite_graph* asset_graph); size_t graphite_stream_read(graphite_stream* stream, void* buffer, size_t size); bool graphite_stream_seek(graphite_stream* stream, uint64_t offset); uint64_t graphite_stream_tell(graphite_stream* stream); void graphite_stream_close(graphite_stream* stream); // // Iterator Functions // // Node iteration graphite_node_iterator* graphite_create_node_iterator( const graphite_graph* graph, const graphite_iterator_config* config ); void graphite_destroy_node_iterator(graphite_node_iterator* iterator); bool graphite_node_iterator_has_next(graphite_node_iterator* iterator); const graphite_graph* graphite_node_iterator_next(graphite_node_iterator* iterator); void graphite_node_iterator_reset(graphite_node_iterator* iterator); uint32_t graphite_node_iterator_get_index(graphite_node_iterator* iterator); // Edge iteration graphite_edge_iterator* graphite_create_edge_iterator( const graphite_graph* graph, const graphite_iterator_config* config ); void graphite_destroy_edge_iterator(graphite_edge_iterator* iterator); bool graphite_edge_iterator_has_next(graphite_edge_iterator* iterator); graphite_edge graphite_edge_iterator_next(graphite_edge_iterator* iterator); void graphite_edge_iterator_reset(graphite_edge_iterator* iterator); uint32_t graphite_edge_iterator_get_index(graphite_edge_iterator* iterator); // Property iteration graphite_property_iterator* graphite_create_property_iterator( const graphite_graph* graph, const graphite_iterator_config* config ); void graphite_destroy_property_iterator(graphite_property_iterator* iterator); bool graphite_property_iterator_has_next(graphite_property_iterator* iterator); graphite_property graphite_property_iterator_next(graphite_property_iterator* iterator); void graphite_property_iterator_reset(graphite_property_iterator* iterator); // // Advanced Graph Algorithms // // Graph traversal modes typedef enum { GRAPHITE_TRAVERSAL_DFS, // Depth-first search GRAPHITE_TRAVERSAL_BFS, // Breadth-first search GRAPHITE_TRAVERSAL_TOPOLOGICAL, // Topological sort GRAPHITE_TRAVERSAL_DIJKSTRA, // Shortest path (Dijkstra) GRAPHITE_TRAVERSAL_CUSTOM, // Custom traversal function } graphite_traversal_mode; // Traversal callback function typedef bool (*graphite_traversal_callback)( const graphite_graph* graph, uint32_t node_index, uint32_t depth, void* user_data ); // Perform graph traversal uint32_t graphite_traverse_graph( const graphite_graph* graph, uint32_t start_node, graphite_traversal_mode mode, graphite_traversal_callback callback, void* user_data, uint32_t* visited_nodes, uint32_t max_nodes ); // Find shortest path between nodes uint32_t graphite_find_shortest_path( const graphite_graph* graph, uint32_t start_node, uint32_t end_node, uint32_t* path, uint32_t max_path_length, float* total_weight ); // Detect cycles in graph bool graphite_has_cycle_detailed( const graphite_graph* graph, uint32_t* cycle_nodes, uint32_t max_cycle_length, uint32_t* cycle_length ); // Find strongly connected components uint32_t graphite_find_strongly_connected_components( const graphite_graph* graph, uint32_t** components, uint32_t* component_sizes, uint32_t max_components ); // // Utility Functions // // Error handling graphite_error graphite_get_last_error(void); const char* graphite_error_string(graphite_error error); void graphite_clear_error(void); // Library version and build information typedef struct { uint32_t major; uint32_t minor; uint32_t patch; const char* string; const char* build_date; const char* build_time; const char* build_config; const char* compiler_name; const char* compiler_version; const char* target_platform; const char* git_commit; bool debug_build; } graphite_version_info; graphite_version_info graphite_get_version_info(void); // Runtime capabilities typedef struct { bool has_threading; bool has_simd; bool has_hardware_crc32; bool has_hardware_crypto; bool has_numa; bool has_huge_pages; bool has_async_io; uint32_t cpu_count; uint32_t cache_line_size; size_t total_memory; } graphite_runtime_capabilities; graphite_runtime_capabilities graphite_get_runtime_capabilities(void); // Performance profiling void graphite_enable_profiling(bool enable); bool graphite_is_profiling_enabled(void); void graphite_reset_profiling_stats(void); // Memory usage information typedef struct { size_t arena_size; // Arena allocation size size_t arena_used; // Arena bytes used size_t arena_peak; // Peak arena usage size_t mmap_size; // Memory mapped file size size_t total_allocated; // Total memory allocated size_t peak_memory; // Peak memory usage uint32_t allocation_count; // Number of allocations uint32_t deallocation_count; // Number of deallocations uint32_t active_allocations; // Currently active allocations double fragmentation_ratio; // Memory fragmentation ratio } graphite_memory_stats; graphite_memory_stats graphite_get_memory_stats(const graphite_bundle* bundle); // Bundle validation typedef enum { GRAPHITE_VALIDATION_QUICK, // Basic format checks GRAPHITE_VALIDATION_STANDARD, // Standard validation GRAPHITE_VALIDATION_THOROUGH, // Comprehensive validation GRAPHITE_VALIDATION_PARANOID, // Maximum validation } graphite_validation_level; typedef struct { bool is_valid; uint32_t error_count; uint32_t warning_count; const char** errors; const char** warnings; uint64_t validation_time_ns; } graphite_validation_result; graphite_validation_result graphite_validate_bundle( const char* file_path, graphite_validation_level level ); void graphite_free_validation_result(graphite_validation_result* result); // Hot reload support typedef void (*graphite_reload_callback)( const graphite_bundle* bundle, void* user_data ); bool graphite_enable_hot_reload( graphite_bundle* bundle, graphite_reload_callback callback, void* user_data ); void graphite_disable_hot_reload(graphite_bundle* bundle); bool graphite_check_for_updates(graphite_bundle* bundle); // Thread safety bool graphite_is_thread_safe(void); void graphite_set_thread_count(uint32_t thread_count); uint32_t graphite_get_thread_count(void); // Global initialization and cleanup bool graphite_initialize(void); void graphite_shutdown(void); bool graphite_is_initialized(void); #ifdef __cplusplus } #endif #endif // GRAPHITE_CORE_H ``` ### Usage Examples #### Basic Bundle Loading and Access ```c #include \"graphite_core.h\" #include <stdio.h> #include <stdlib.h> int main() { // Initialize GRAPHITE library if (!graphite_initialize()) { fprintf(stderr, \"Failed to initialize GRAPHITE\ \"); return 1; } // Open bundle with hash verification and compression uint32_t flags = GRAPHITE_VERIFY_HASHES | GRAPHITE_DECOMPRESS | GRAPHITE_HW_ACCELERATION; graphite_performance_stats stats = {0}; graphite_bundle* bundle = graphite_open_ex(\"assets/game.graphite\", flags, &stats); if (!bundle) { graphite_error error = graphite_get_last_error(); fprintf(stderr, \"Failed to open bundle: %s\ \", graphite_error_string(error)); graphite_shutdown(); return 1; } // Print loading performance printf(\"Bundle loaded successfully!\ \"); printf(\"Load time: %.2f ms\ \", stats.total_load_time_ns / 1e6); printf(\"Peak memory: %.2f MB\ \", stats.peak_memory_usage / (1024.0 * 1024.0)); printf(\"Compression ratio: %.2f%%\ \", stats.compression_ratio * 100.0); // Get bundle information graphite_bundle_info info = graphite_get_bundle_info(bundle); printf(\"Bundle contains:\ \"); printf(\" %u chunks (%u graphs, %u blobs)\ \", info.chunk_count, info.graph_count, info.blob_count); printf(\" %llu total nodes, %llu total edges\ \", info.total_nodes, info.total_edges); printf(\" %u image assets, %u audio assets\ \", info.image_assets, info.audio_assets); // Access root graph const graphite_graph* root = graphite_get_root_graph(bundle); printf(\"Root graph has %u child nodes\ \", graphite_get_node_count(root)); // Iterate through child nodes for (uint32_t i = 0; i < graphite_get_node_count(root); i++) { const graphite_graph* child = graphite_get_node(root, i); // Check if this is an asset if (graphite_get_node_count(child) == 0) { const char* mime_type = graphite_get_asset_mime_type(child); if (mime_type) { size_t data_size; const void* data = graphite_get_asset_data(child, &data_size); printf(\"Asset %u: %s (%zu bytes)\ \", i, mime_type, data_size); } } } // Search for specific assets const graphite_graph* texture_graph = graphite_find_node_by_property( root, \"mime_type\", &(graphite_property_value){ .type = GRAPHITE_PROPERTY_STRING, .string_value = \"image/png\" } ); if (texture_graph) { printf(\"Found PNG texture asset\ \"); } graphite_close(bundle); graphite_shutdown(); return 0; } ``` #### Advanced Property Access and Graph Traversal ```c #include \"graphite_core.h\" #include <stdio.h> #include <string.h> void print_properties(const graphite_graph* graph, const char* indent) { uint32_t prop_count = graphite_get_property_count(graph); for (uint32_t i = 0; i < prop_count; i++) { graphite_property prop = graphite_get_property_by_index(graph, i); printf(\"%s%s: \", indent, prop.key); switch (prop.value.type) { case GRAPHITE_PROPERTY_BOOLEAN: printf(\"%s\", prop.value.boolean_value ? \"true\" : \"false\"); break; case GRAPHITE_PROPERTY_INTEGER: printf(\"%lld\", prop.value.integer_value); break; case GRAPHITE_PROPERTY_FLOAT: printf(\"%.6f\", prop.value.float_value); break; case GRAPHITE_PROPERTY_STRING: printf(\"\\\"%s\\\"\", prop.value.string_value); break; case GRAPHITE_PROPERTY_VECTOR3: printf(\"(%.3f, %.3f, %.3f)\", prop.value.vector3_value.x, prop.value.vector3_value.y, prop.value.vector3_value.z); break; case GRAPHITE_PROPERTY_COLOR: printf(\"rgba(%.3f, %.3f, %.3f, %.3f)\", prop.value.color_value.r, prop.value.color_value.g, prop.value.color_value.b, prop.value.color_value.a); break; case GRAPHITE_PROPERTY_TIMESTAMP: printf(\"timestamp(%llu)\", prop.value.timestamp_value); break; default: printf(\"(complex type: %d)\", prop.value.type); break; } printf(\"\ \"); } } bool traverse_callback( const graphite_graph* graph, uint32_t node_index, uint32_t depth, void* user_data ) { int* node_count = (int*)user_data; (*node_count)++; // Print indentation based on depth for (uint32_t i = 0; i < depth; i++) { printf(\" \"); } printf(\"Node %u (depth %u):\ \", node_index, depth); const graphite_graph* node = graphite_get_node(graph, node_index); if (node) { char indent[64]; snprintf(indent, sizeof(indent), \"%*s \", (int)depth * 2 + 2, \"\"); print_properties(node, indent); } return true; // Continue traversal } int main() { if (!graphite_initialize()) { return 1; } graphite_bundle* bundle = graphite_open(\"assets/complex_scene.graphite\"); if (!bundle) { fprintf(stderr, \"Failed to open bundle\ \"); return 1; } const graphite_graph* root = graphite_get_root_graph(bundle); // Perform depth-first traversal printf(\"Depth-first traversal of scene graph:\ \"); int node_count = 0; uint32_t visited[1000]; uint32_t visited_count = graphite_traverse_graph( root, 0, // Start from first node GRAPHITE_TRAVERSAL_DFS, traverse_callback, &node_count, visited, 1000 ); printf(\"Visited %u nodes total\ \", visited_count); // Find assets with specific properties printf(\"\ Searching for high-resolution textures:\ \"); for (uint32_t i = 0; i < graphite_get_node_count(root); i++) { const graphite_graph* node = graphite_get_node(root, i); // Check if it's a texture asset const char* mime_type; if (graphite_get_string_property(node, \"mime_type\", &mime_type) && strstr(mime_type, \"image/\")) { uint64_t size; if (graphite_get_unsigned_property(node, \"size\", &size) && size > 1024 * 1024) { // > 1MB printf(\" Large texture: %s (%llu bytes)\ \", mime_type, size); } } } // Find dependency relationships printf(\"\ Dependency analysis:\ \"); uint32_t edge_count = graphite_get_edge_count(root); for (uint32_t i = 0; i < edge_count; i++) { graphite_edge edge = graphite_get_edge(root, i); const char* edge_type; if (graphite_get_string_property(edge.edge_data, \"type\", &edge_type) && strcmp(edge_type, \"dependency\") == 0) { printf(\" Node %u depends on Node %u\ \", edge.to_node_index, edge.from_node_index); } } graphite_close(bundle); graphite_shutdown(); return 0; } ``` #### Asynchronous Loading with Callbacks ```c #include \"graphite_core.h\" #include <stdio.h> #include <unistd.h> typedef struct { const char* bundle_name; bool loading_complete; graphite_bundle* result_bundle; graphite_error result_error; } loading_context; void loading_completion_callback( graphite_bundle* bundle, graphite_error error, void* user_data ) { loading_context* ctx = (loading_context*)user_data; ctx->result_bundle = bundle; ctx->result_error = error; ctx->loading_complete = true; if (error == GRAPHITE_OK) { printf(\"‚úì Successfully loaded %s\ \", ctx->bundle_name); graphite_bundle_info info = graphite_get_bundle_info(bundle); printf(\" %u chunks, %.2f MB\ \", info.chunk_count, info.file_size / (1024.0 * 1024.0)); } else { printf(\"‚úó Failed to load %s: %s\ \", ctx->bundle_name, graphite_error_string(error)); } } int main() { if (!graphite_initialize()) { return 1; } // Start multiple asynchronous loads const char* bundle_files[] = { \"assets/level1.graphite\", \"assets/level2.graphite\", \"assets/ui.graphite\", \"assets/audio.graphite\" }; const int bundle_count = sizeof(bundle_files) / sizeof(bundle_files[0]); loading_context contexts[bundle_count]; graphite_async_handle* handles[bundle_count]; printf(\"Starting asynchronous loading of %d bundles...\ \", bundle_count); for (int i = 0; i < bundle_count; i++) { contexts[i].bundle_name = bundle_files[i]; contexts[i].loading_complete = false; contexts[i].result_bundle = NULL; contexts[i].result_error = GRAPHITE_OK; handles[i] = graphite_open_async( bundle_files[i], GRAPHITE_VERIFY_HASHES | GRAPHITE_DECOMPRESS, loading_completion_callback, &contexts[i] ); if (!handles[i]) { printf(\"Failed to start loading %s\ \", bundle_files[i]); } } // Wait for all loads to complete bool all_complete = false; while (!all_complete) { all_complete = true; for (int i = 0; i < bundle_count; i++) { if (handles[i] && !graphite_async_is_complete(handles[i])) { all_complete = false; break; } } if (!all_complete) { printf(\".\"); fflush(stdout); usleep(100000); // 100ms } } printf(\"\ All bundles loaded!\ \"); // Process results int successful_loads = 0; for (int i = 0; i < bundle_count; i++) { if (contexts[i].result_error == GRAPHITE_OK) { successful_loads++; // Do something with the loaded bundle const graphite_graph* root = graphite_get_root_graph(contexts[i].result_bundle); printf(\"%s: %u nodes\ \", contexts[i].bundle_name, graphite_get_node_count(root)); } } printf(\"%d of %d bundles loaded successfully\ \", successful_loads, bundle_count); // Cleanup for (int i = 0; i < bundle_count; i++) { if (contexts[i].result_bundle) { graphite_close(contexts[i].result_bundle); } if (handles[i]) { graphite_async_destroy(handles[i]); } } graphite_shutdown(); return 0; } ``` --- ## Tooling API Specification ### Bundle Creation and Analysis API (graphite_tooling.h) The tooling API provides comprehensive functionality for creating, analyzing, and manipulating GRAPHITE bundles: ```c #ifndef GRAPHITE_TOOLING_H #define GRAPHITE_TOOLING_H #include \"graphite_core.h\" #include <stdint.h> #include <stdbool.h> #include <time.h> #ifdef __cplusplus extern \"C\" { #endif // Forward declarations for tooling types typedef struct graphite_writer graphite_writer; typedef struct graphite_graph_builder graphite_graph_builder; typedef struct graphite_string_pool_builder graphite_string_pool_builder; typedef struct graphite_integrity_builder graphite_integrity_builder; typedef struct graphite_analyzer graphite_analyzer; typedef struct graphite_optimizer graphite_optimizer; typedef struct graphite_validator graphite_validator; // // Bundle Writer Configuration // // Compression configuration with advanced options typedef struct { int level; // zstd compression level (0-22) bool enable_dictionary; // Use dictionary compression size_t dictionary_size; // Maximum dictionary size size_t min_chunk_size; // Minimum size to attempt compression double min_compression_ratio; // Minimum compression ratio to keep uint32_t max_compression_time_ms; // Maximum time to spend compressing bool adaptive_level; // Automatically adjust level based on content bool parallel_compression; // Use multiple threads for compression uint32_t thread_count; // Number of compression threads // Advanced dictionary training bool auto_train_dictionaries; // Automatically train dictionaries uint32_t training_sample_limit; // Maximum samples for training double dictionary_effectiveness_threshold; // Minimum effectiveness to use dictionary // Content-specific settings const char** file_patterns; // File patterns for dictionary training uint32_t pattern_count; // Number of patterns bool compress_similar_content_together; // Group similar content for compression } graphite_compression_config; // Integrity configuration with multiple algorithms typedef struct { bool enable_hashing; // Enable BLAKE3 hash tree bool mandatory_verification; // Set mandatory verification flag int tree_fanout; // Hash tree branching factor (2-32) bool include_chunk_hashes; // Include individual chunk hashes bool enable_signatures; // Enable digital signatures const uint8_t* signing_key; // Private key for signing (32 bytes for Ed25519) bool timestamp_hashes; // Include timestamps in hashes uint32_t hash_algorithm; // Hash algorithm (BLAKE3 = 1) // Advanced integrity features bool enable_merkle_proofs; // Enable Merkle proof generation bool enable_incremental_verification; // Support incremental verification bool enable_tamper_evidence; // Include tamper evidence } graphite_integrity_config; // Output configuration with advanced options typedef struct { const char* output_path; // Output file path bool overwrite_existing; // Overwrite if file exists uint32_t file_permissions; // File permissions (Unix style) bool create_backup; // Create .bak file if overwriting bool atomic_write; // Use atomic write operations bool sync_to_disk; // Force sync to disk // Advanced output options bool create_manifest; // Create companion manifest file bool create_checksum_file; // Create separate checksum file bool create_metadata_file; // Create metadata sidecar file const char* temp_directory; // Temporary directory for atomic writes } graphite_output_config; // Bundle metadata configuration typedef struct { const char* title; // Bundle title const char* description; // Bundle description const char* author; // Author/creator const char* version; // Bundle version const char* license; // License information const char* copyright; // Copyright notice const char** tags; // Searchable tags uint32_t tag_count; // Number of tags const char** categories; // Asset categories uint32_t category_count; // Number of categories // Build information const char* build_tool; // Tool used to create bundle const char* build_version; // Tool version const char* build_configuration; // Build configuration uint64_t build_timestamp; // Build timestamp const char* source_repository; // Source code repository const char* source_commit; // Source commit hash // Target information const char** target_platforms; // Target platforms uint32_t target_platform_count; // Number of target platforms const char* minimum_engine_version; // Minimum engine version required const char** required_features; // Required engine features uint32_t required_feature_count; // Number of required features } graphite_bundle_metadata; // Writer statistics with detailed breakdowns typedef struct { // Input statistics uint64_t total_input_size; // Total input data size uint64_t total_input_files; // Number of input files uint32_t total_input_graphs; // Number of input graphs // Output statistics uint64_t total_output_size; // Total output file size uint32_t chunks_written; // Number of chunks written uint32_t chunks_compressed; // Number of compressed chunks uint32_t graphs_created; // Number of graph chunks created uint32_t blobs_created; // Number of blob chunks created uint32_t strings_deduplicated; // Number of strings deduplicated // Compression statistics double overall_compression_ratio; // Overall compression effectiveness uint64_t compression_time_ns; // Time spent compressing uint64_t decompression_verification_time_ns; // Time spent verifying decompression uint32_t dictionary_trained_count; // Number of dictionaries trained uint64_t dictionary_training_time_ns; // Time spent training dictionaries // Integrity statistics uint64_t hashing_time_ns; // Time spent computing hashes uint32_t hash_tree_nodes; // Number of hash tree nodes uint32_t signature_time_ns; // Time spent signing // Performance statistics uint64_t total_write_time_ns; // Total write time uint64_t peak_memory_usage; // Peak memory usage during creation uint32_t threads_used; // Number of threads used double cpu_utilization; // CPU utilization percentage // Quality statistics double estimated_load_time_ms; // Estimated load time uint32_t cache_friendliness_score; // Cache optimization score (0-100) uint32_t fragmentation_score; // Data fragmentation score (0-100) } graphite_writer_stats; // // Bundle Writer Functions // // Create bundle writer with comprehensive configuration graphite_writer* graphite_writer_create(const graphite_output_config* output_config); // Configure all aspects of bundle creation void graphite_writer_set_compression(graphite_writer* writer, const graphite_compression_config* config); void graphite_writer_set_integrity(graphite_writer* writer, const graphite_integrity_config* config); void graphite_writer_set_metadata(graphite_writer* writer, const graphite_bundle_metadata* metadata); // Advanced writer configuration void graphite_writer_set_thread_count(graphite_writer* writer, uint32_t thread_count); void graphite_writer_set_memory_limit(graphite_writer* writer, size_t memory_limit); void graphite_writer_set_optimization_level(graphite_writer* writer, uint32_t level); // Progress monitoring typedef void (*graphite_progress_callback)( uint32_t current_step, uint32_t total_steps, const char* step_description, void* user_data ); void graphite_writer_set_progress_callback( graphite_writer* writer, graphite_progress_callback callback, void* user_data ); // Finalize and write bundle to disk bool graphite_writer_finalize(graphite_writer* writer, graphite_writer_stats* stats); // Cancel writing operation void graphite_writer_cancel(graphite_writer* writer); // Destroy writer and free resources void graphite_writer_destroy(graphite_writer* writer); // // Graph Builder Functions // // Graph builder with advanced features graphite_graph_builder* graphite_graph_builder_create(void); // Configure graph characteristics void graphite_graph_builder_set_flags(graphite_graph_builder* builder, uint32_t flags); void graphite_graph_builder_set_parallel_hint(graphite_graph_builder* builder, bool parallel); void graphite_graph_builder_set_cache_hint(graphite_graph_builder* builder, uint32_t cache_priority); // Add nodes with various sources uint32_t graphite_graph_builder_add_asset_node( graphite_graph_builder* builder, const void* data, size_t size, const char* mime_type ); uint32_t graphite_graph_builder_add_asset_file( graphite_graph_builder* builder, const char* file_path, const char* mime_type ); uint32_t graphite_graph_builder_add_asset_stream( graphite_graph_builder* builder, int (*read_func)(void* buffer, size_t size, void* user_data), size_t total_size, const char* mime_type, void* user_data ); uint32_t graphite_graph_builder_add_graph_node( graphite_graph_builder* builder, const graphite_graph* subgraph ); uint32_t graphite_graph_builder_add_graph_reference( graphite_graph_builder* builder, uint32_t chunk_index ); // Advanced edge creation void graphite_graph_builder_add_edge( graphite_graph_builder* builder, uint32_t from_node, uint32_t to_node, const graphite_graph* edge_semantics ); void graphite_graph_builder_add_simple_edge( graphite_graph_builder* builder, uint32_t from_node, uint32_t to_node, const char* edge_type, const char* metadata ); void graphite_graph_builder_add_weighted_edge( graphite_graph_builder* builder, uint32_t from_node, uint32_t to_node, float weight, uint32_t priority ); void graphite_graph_builder_add_conditional_edge( graphite_graph_builder* builder, uint32_t from_node, uint32_t to_node, const char* condition_expression ); // Comprehensive property system void graphite_graph_builder_set_property_null( graphite_graph_builder* builder, const char* key ); void graphite_graph_builder_set_property_boolean( graphite_graph_builder* builder, const char* key, bool value ); void graphite_graph_builder_set_property_integer( graphite_graph_builder* builder, const char* key, int64_t value ); void graphite_graph_builder_set_property_unsigned( graphite_graph_builder* builder, const char* key, uint64_t value ); void graphite_graph_builder_set_property_float( graphite_graph_builder* builder, const char* key, double value ); void graphite_graph_builder_set_property_string( graphite_graph_builder* builder, const char* key, const char* value ); void graphite_graph_builder_set_property_timestamp( graphite_graph_builder* builder, const char* key, uint64_t timestamp_ns ); void graphite_graph_builder_set_property_uuid( graphite_graph_builder* builder, const char* key, const uint8_t uuid[16] ); void graphite_graph_builder_set_property_vector3( graphite_graph_builder* builder, const char* key, float x, float y, float z ); void graphite_graph_builder_set_property_color( graphite_graph_builder* builder, const char* key, float r, float g, float b, float a ); void graphite_graph_builder_set_property_matrix4( graphite_graph_builder* builder, const char* key, const float matrix[16] ); void graphite_graph_builder_set_property_bounding_box( graphite_graph_builder* builder, const char* key, float min_x, float min_y, float min_z, float max_x, float max_y, float max_z ); // Array and object properties void graphite_graph_builder_begin_property_array( graphite_graph_builder* builder, const char* key ); void graphite_graph_builder_add_array_element_string( graphite_graph_builder* builder, const char* value ); void graphite_graph_builder_add_array_element_integer( graphite_graph_builder* builder, int64_t value ); void graphite_graph_builder_end_property_array( graphite_graph_builder* builder ); void graphite_graph_builder_begin_property_object( graphite_graph_builder* builder, const char* key ); void graphite_graph_builder_end_property_object( graphite_graph_builder* builder ); // Import from other formats bool graphite_graph_builder_import_json( graphite_graph_builder* builder, const char* json_data, size_t json_size ); bool graphite_graph_builder_import_yaml( graphite_graph_builder* builder, const char* yaml_data, size_t yaml_size ); bool graphite_graph_builder_import_xml( graphite_graph_builder* builder, const char* xml_data, size_t xml_size ); // Validation and optimization bool graphite_graph_builder_validate( graphite_graph_builder* builder, char* error_buffer, size_t error_buffer_size ); void graphite_graph_builder_optimize(graphite_graph_builder* builder); // Finalize graph and add to writer uint32_t graphite_writer_add_graph(graphite_writer* writer, graphite_graph_builder* builder); // Destroy graph builder void graphite_graph_builder_destroy(graphite_graph_builder* builder); // // String Pool Builder Functions // // Advanced string pool with optimization graphite_string_pool_builder* graphite_string_pool_builder_create(void); // String management uint32_t graphite_string_pool_add_string( graphite_string_pool_builder* builder, const char* string ); uint32_t graphite_string_pool_add_string_with_length( graphite_string_pool_builder* builder, const char* string, size_t length ); void graphite_string_pool_add_strings( graphite_string_pool_builder* builder, const char** strings, uint32_t count ); // String pool optimization void graphite_string_pool_optimize(graphite_string_pool_builder* builder); void graphite_string_pool_remove_unused(graphite_string_pool_builder* builder); void graphite_string_pool_sort_by_frequency(graphite_string_pool_builder* builder); // Load strings from various sources bool graphite_string_pool_load_from_file( graphite_string_pool_builder* builder, const char* file_path ); bool graphite_string_pool_load_from_json( graphite_string_pool_builder* builder, const char* json_data, size_t json_size ); bool graphite_string_pool_scan_directory( graphite_string_pool_builder* builder, const char* directory_path, const char** file_patterns, uint32_t pattern_count ); // String pool statistics typedef struct { uint32_t unique_strings; // Number of unique strings uint32_t total_references; // Total string references size_t total_bytes; // Total string data bytes size_t compressed_bytes; // Bytes after compression double deduplication_ratio; // Space saved by deduplication uint32_t most_frequent_string_refs; // References to most frequent string uint32_t unused_strings; // Strings with no references double average_string_length; // Average string length uint32_t max_string_length; // Maximum string length } graphite_string_pool_builder_stats; graphite_string_pool_builder_stats graphite_string_pool_get_stats( graphite_string_pool_builder* builder ); // Finalize string pool and add to writer uint32_t graphite_writer_set_string_pool( graphite_writer* writer, graphite_string_pool_builder* builder ); // Destroy string pool builder void graphite_string_pool_builder_destroy(graphite_string_pool_builder* builder); // // Compression Dictionary Training // // Advanced dictionary training with machine learning typedef struct { size_t max_dictionary_size; // Maximum dictionary size uint32_t sample_count_limit; // Maximum training samples size_t max_sample_size; // Maximum size per sample double min_compression_gain; // Minimum compression improvement uint32_t clustering_iterations; // K-means clustering iterations bool enable_content_clustering; // Cluster by content similarity bool enable_adaptive_sampling; // Adaptive sample selection double similarity_threshold; // Content similarity threshold } graphite_dictionary_config; // Train dictionaries with advanced algorithms bool graphite_train_dictionary_advanced( const char** file_paths, uint32_t file_count, const graphite_dictionary_config* config, void** dictionary_data, size_t* dictionary_size ); // Train from memory samples with clustering bool graphite_train_dictionary_clustered( const void** samples, const size_t* sample_sizes, const char** content_types, uint32_t sample_count, const graphite_dictionary_config* config, void*** dictionaries, size_t** dictionary_sizes, char*** dictionary_targets, uint32_t* dictionary_count ); // Evaluate dictionary effectiveness typedef struct { double compression_improvement; // Compression ratio improvement uint64_t training_time_ns; // Time spent training uint32_t effective_sample_count; // Samples that benefited from dictionary double average_compression_speedup; // Compression speed improvement double decompression_speedup; // Decompression speed improvement } graphite_dictionary_evaluation; graphite_dictionary_evaluation graphite_evaluate_dictionary( const void* dictionary_data, size_t dictionary_size, const void** test_samples, const size_t* test_sample_sizes, uint32_t test_sample_count ); // Add trained dictionaries to writer void graphite_writer_add_dictionary( graphite_writer* writer, const void* dictionary_data, size_t dictionary_size, const char* target_content_type ); // // Bundle Analysis Functions // // Comprehensive bundle analyzer graphite_analyzer* graphite_analyzer_create(const graphite_bundle* bundle); // Analysis configuration typedef struct { bool analyze_performance; // Analyze performance characteristics bool analyze_compression; // Analyze compression effectiveness bool analyze_integrity; // Analyze integrity features bool analyze_dependencies; // Analyze dependency structure bool analyze_content_types; // Analyze content type distribution bool analyze_access_patterns; // Analyze likely access patterns bool generate_visualizations; // Generate visualization data uint32_t max_analysis_time_ms; // Maximum time to spend analyzing } graphite_analysis_config; void graphite_analyzer_configure( graphite_analyzer* analyzer, const graphite_analysis_config* config ); // Detailed analysis results typedef struct { uint32_t total_graphs; // Total number of graphs uint32_t leaf_graphs; // Number of leaf (asset) graphs uint32_t string_pools; // Number of string pool graphs uint32_t parallel_groups; // Number of parallel group graphs uint32_t transform_graphs; // Number of transform graphs uint32_t max_depth; // Maximum graph nesting depth uint32_t total_nodes; // Total nodes across all graphs uint32_t total_edges; // Total edges across all graphs double avg_branching_factor; // Average branching factor bool has_cycles; // Whether any graph has cycles uint32_t strongly_connected_components; // Number of SCCs double graph_density; // Graph density metric uint32_t longest_path_length; // Longest path in DAG } graphite_graph_analysis; typedef struct { uint64_t total_size; // Total bundle size uint64_t header_size; // Header and metadata size uint64_t chunk_table_size; // Chunk table size uint64_t chunk_data_size; // Total chunk data size uint64_t compressed_size; // Size of compressed chunks uint64_t uncompressed_size; // Size before compression double compression_ratio; // Overall compression ratio uint32_t compression_chunks; // Number of compressed chunks uint32_t compression_failures; // Chunks that didn't compress well double compression_time_estimate; // Estimated compression time uint32_t dictionary_count; // Number of compression dictionaries size_t largest_chunk_size; // Size of largest chunk size_t smallest_chunk_size; // Size of smallest chunk double chunk_size_variance; // Variance in chunk sizes } graphite_compression_analysis; typedef struct { bool has_integrity_tree; // Has hash tree uint32_t hash_nodes; // Number of hash nodes uint32_t hash_leaves; // Number of hash leaves uint32_t protected_chunks; // Number of protected chunks double verification_coverage; // Percentage of data protected bool mandatory_verification; // Verification is mandatory uint64_t verification_time_estimate; // Estimated verification time bool has_signatures; // Has digital signatures uint32_t signature_count; // Number of signatures bool has_timestamps; // Has timestamp verification } graphite_integrity_analysis; typedef struct { uint32_t unique_strings; // Number of unique strings uint32_t total_references; // Total string references size_t string_data_size; // Total string data size double deduplication_ratio; // Space saved by deduplication uint32_t unused_strings; // Strings with no references double fragmentation_ratio; // String pool fragmentation uint32_t most_referenced_string_count; // Refs to most popular string double average_string_length; // Average string length uint32_t strings_over_1kb; // Number of large strings } graphite_string_analysis; typedef struct { uint32_t image_assets; // Number of image assets uint32_t audio_assets; // Number of audio assets uint32_t mesh_assets; // Number of mesh assets uint32_t script_assets; // Number of script assets uint32_t font_assets; // Number of font assets uint32_t video_assets; // Number of video assets uint32_t document_assets; // Number of document assets uint32_t unknown_assets; // Number of unknown assets size_t image_total_size; // Total size of image assets size_t audio_total_size; // Total size of audio assets size_t mesh_total_size; // Total size of mesh assets size_t script_total_size; // Total size of script assets const char** mime_types; // All MIME types found uint32_t* mime_type_counts; // Count per MIME type uint32_t mime_type_count; // Number of unique MIME types } graphite_content_analysis; typedef struct { double estimated_sequential_load_time; // Sequential load time estimate double estimated_parallel_load_time; // Parallel load time estimate double cache_hit_probability; // Probability of cache hits uint32_t hot_chunks; // Number of frequently accessed chunks uint32_t cold_chunks; // Number of rarely accessed chunks double memory_locality_score; // Memory access locality score uint32_t critical_path_length; // Critical path for loading double parallelization_potential; // Potential for parallel loading } graphite_performance_analysis; // Perform various analyses graphite_graph_analysis graphite_analyzer_analyze_graphs(graphite_analyzer* analyzer); graphite_compression_analysis graphite_analyzer_analyze_compression(graphite_analyzer* analyzer); graphite_integrity_analysis graphite_analyzer_analyze_integrity(graphite_analyzer* analyzer); graphite_string_analysis graphite_analyzer_analyze_strings(graphite_analyzer* analyzer); graphite_content_analysis graphite_analyzer_analyze_content_types(graphite_analyzer* analyzer); graphite_performance_analysis graphite_analyzer_analyze_performance(graphite_analyzer* analyzer); // Comprehensive optimization recommendations typedef struct { // Compression recommendations bool enable_compression; // Recommendation to enable compression int suggested_compression_level; // Suggested compression level bool enable_dictionary; // Recommendation for dictionary training const char** dictionary_targets; // Suggested dictionary target types uint32_t dictionary_target_count; // Number of dictionary targets // Structure recommendations bool improve_string_dedup; // String deduplication improvements bool reorganize_chunks; // Reorganize chunks for better locality bool merge_small_chunks; // Merge small chunks for efficiency bool split_large_chunks; // Split large chunks for parallelism // Integrity recommendations bool add_integrity_tree; // Add hash tree recommendation bool add_signatures; // Add digital signature recommendation bool optimize_hash_tree; // Optimize hash tree structure // Performance recommendations bool optimize_for_sequential_access; // Optimize for sequential access bool optimize_for_random_access; // Optimize for random access bool add_parallelization_hints; // Add parallel processing hints bool improve_cache_locality; // Improve cache locality // Overall recommendations double potential_size_reduction; // Estimated size reduction percentage double potential_load_time_improvement; // Estimated load time improvement uint32_t priority_score; // Recommendation priority (0-100) const char* primary_recommendation; // Primary optimization suggestion const char** detailed_recommendations; // Detailed suggestion list uint32_t recommendation_count; // Number of detailed recommendations } graphite_optimization_recommendations; graphite_optimization_recommendations graphite_analyzer_get_recommendations( graphite_analyzer* analyzer ); // Generate detailed report typedef struct { const char* report_format; // \"text\", \"json\", \"xml\", \"html\" bool include_visualizations; // Include charts and graphs bool include_raw_data; // Include raw analysis data bool include_recommendations; // Include optimization recommendations uint32_t max_report_size; // Maximum report size in bytes } graphite_report_config; bool graphite_analyzer_generate_report( graphite_analyzer* analyzer, const graphite_report_config* config, const char* output_path ); // Destroy analyzer void graphite_analyzer_destroy(graphite_analyzer* analyzer); // // Bundle Comparison and Diffing // // Comprehensive bundle comparison typedef struct { bool structure_identical; // Same graph structure bool content_identical; // Same content hashes bool metadata_identical; // Same metadata uint32_t added_graphs; // Number of added graphs uint32_t removed_graphs; // Number of removed graphs uint32_t modified_graphs; // Number of modified graphs uint32_t moved_graphs; // Number of moved graphs uint32_t added_chunks; // Number of added chunks uint32_t removed_chunks; // Number of removed chunks uint32_t modified_chunks; // Number of modified chunks uint64_t size_difference; // Size difference in bytes double compression_ratio_change; // Change in compression ratio // Detailed change information uint32_t* changed_chunk_indices; // Indices of changed chunks uint32_t changed_chunk_count; // Number of changed chunks const char** change_descriptions; // Human-readable change descriptions uint32_t change_description_count; // Number of change descriptions } graphite_comparison_result; graphite_comparison_result graphite_compare_bundles( const graphite_bundle* bundle1, const graphite_bundle* bundle2 ); graphite_comparison_result graphite_compare_bundle_files( const char* file_path1, const char* file_path2 ); // Generate binary diff for efficient updates typedef struct { const void* diff_data; // Binary diff data size_t diff_size; // Size of diff data double compression_ratio; // Diff compression ratio bool applicable; // Whether diff can be applied uint64_t generation_time_ns; // Time to generate diff uint32_t operations_count; // Number of diff operations } graphite_binary_diff; graphite_binary_diff graphite_create_binary_diff( const graphite_bundle* old_bundle, const graphite_bundle* new_bundle ); graph`, `old_str`: `void queue_optimized_read( advanced_async_io* ctx, int fd, uint32_t chunk_index, size_t size, off_t offset ) { if (ctx->pending_ops >= ctx->queue_depth) { // Wait for at least one completion wait_for_completions(ctx, 1); } uint32_t op_index = ctx->pending_ops; // Setup I/O vector ctx->iovecs[op_index].iov_base = ctx->buffers[op_index]; ctx->iovecs[op_index].iov_len = min(size,`, `file_path`: `/home/user/git/graphite/spec_claude.md` }``

Retry

JR

Continue

Edit

Mapped out comprehensive GRAPHITE specification document roadmap.

5s

C

Edit

Request

``{ `new_str`: `graphite_binary_diff graphite_create_binary_diff( const graphite_bundle* old_bundle, const graphite_bundle* new_bundle ); graphite_binary_diff graphite_create_binary_diff_files( const char* old_file_path, const char* new_file_path ); // Apply binary diff to create new bundle bool graphite_apply_binary_diff( const graphite_bundle* base_bundle, const graphite_binary_diff* diff, const char* output_path ); bool graphite_apply_binary_diff_files( const char* base_file_path, const void* diff_data, size_t diff_size, const char* output_path ); // Verify diff can be applied bool graphite_verify_binary_diff( const graphite_bundle* base_bundle, const graphite_binary_diff* diff ); // Free binary diff resources void graphite_free_binary_diff(graphite_binary_diff* diff); // Free comparison result void graphite_free_comparison_result(graphite_comparison_result* result); // // Validation and Repair Functions // // Advanced validation with configurable levels typedef enum { GRAPHITE_VALIDATE_QUICK, // Basic format validation GRAPHITE_VALIDATE_STANDARD, // Standard validation with integrity GRAPHITE_VALIDATE_THOROUGH, // Comprehensive validation GRAPHITE_VALIDATE_FORENSIC, // Maximum validation with detailed analysis } graphite_validation_level; // Validation configuration typedef struct { graphite_validation_level level; // Validation thoroughness bool check_file_integrity; // Verify file-level integrity bool check_chunk_integrity; // Verify chunk-level integrity bool check_graph_structure; // Validate graph structure bool check_property_types; // Validate property types bool check_string_references; // Validate string pool references bool check_cross_references; // Validate cross-references bool check_dependency_cycles; // Check for dependency cycles bool generate_repair_plan; // Generate repair recommendations uint32_t max_validation_time_ms; // Maximum validation time uint32_t max_errors_to_collect; // Maximum errors to collect } graphite_validation_config; // Detailed validation result typedef struct { bool is_valid; // Overall validation result graphite_validation_level level_used; // Validation level actually used uint64_t validation_time_ns; // Time spent validating // Error and warning counts uint32_t error_count; // Number of errors found uint32_t warning_count; // Number of warnings found uint32_t info_count; // Number of informational messages // Detailed messages const char** errors; // Array of error messages const char** warnings; // Array of warning messages const char** info_messages; // Array of info messages // Error categories uint32_t format_errors; // Format-related errors uint32_t integrity_errors; // Integrity-related errors uint32_t structure_errors; // Graph structure errors uint32_t reference_errors; // Reference resolution errors // Repair information bool can_be_repaired; // Whether bundle can be repaired uint32_t repair_operations_needed; // Number of repair operations const char** repair_recommendations; // Repair recommendations uint32_t repair_recommendation_count; // Number of repair recommendations // Detailed analysis (for forensic level) uint32_t corrupted_chunks; // Number of corrupted chunks uint32_t missing_chunks; // Number of missing chunks uint32_t orphaned_chunks; // Number of orphaned chunks double data_recovery_percentage; // Percentage of data recoverable } graphite_validation_result; // Validate bundle with comprehensive options graphite_validation_result graphite_validate_bundle_advanced( const char* bundle_path, const graphite_validation_config* config ); // Validate in-memory bundle graphite_validation_result graphite_validate_bundle_memory( const graphite_bundle* bundle, const graphite_validation_config* config ); // Repair bundle based on validation results typedef struct { bool fix_format_errors; // Fix format-related errors bool fix_integrity_errors; // Fix integrity errors where possible bool rebuild_string_pool; // Rebuild string pool bool remove_corrupted_chunks; // Remove irreparably corrupted chunks bool optimize_structure; // Optimize structure during repair bool create_backup; // Create backup before repair const char* backup_suffix; // Suffix for backup file } graphite_repair_config; bool graphite_repair_bundle( const char* input_path, const char* output_path, const graphite_validation_result* validation, const graphite_repair_config* config ); // Attempt automatic repair bool graphite_auto_repair_bundle( const char* bundle_path, bool create_backup ); // Free validation result void graphite_free_validation_result(graphite_validation_result* result); // // Format Conversion Functions // // Supported export formats typedef enum { GRAPHITE_EXPORT_JSON, // JSON representation GRAPHITE_EXPORT_YAML, // YAML representation GRAPHITE_EXPORT_XML, // XML representation GRAPHITE_EXPORT_DOT, // Graphviz DOT format GRAPHITE_EXPORT_MERMAID, // Mermaid diagram format GRAPHITE_EXPORT_CSV, // CSV for tabular data GRAPHITE_EXPORT_SQL, // SQL database dump GRAPHITE_EXPORT_CYPHER, // Neo4j Cypher queries GRAPHITE_EXPORT_GEXF, // Graph Exchange XML Format GRAPHITE_EXPORT_GRAPHML, // GraphML format } graphite_export_format; // Export configuration typedef struct { graphite_export_format format; // Target format bool include_binary_data; // Include base64-encoded binary data bool pretty_print; // Format for human readability uint32_t max_depth; // Maximum nesting depth const char* filter_expression; // Filter expression for selective export bool include_metadata; // Include bundle metadata bool include_statistics; // Include analysis statistics bool resolve_references; // Resolve all references const char* encoding; // Character encoding (UTF-8, etc.) // Format-specific options union { struct { bool compact_arrays; // Compact array representation bool include_schema; // Include JSON schema } json_options; struct { bool include_dtd; // Include DTD bool validate_xml; // Validate XML output } xml_options; struct { const char* graph_direction; // \"TB\", \"BT\", \"LR\", \"RL\" bool include_styling; // Include visual styling } mermaid_options; struct { char delimiter; // CSV delimiter character bool include_headers; // Include column headers } csv_options; }; } graphite_export_config; // Export bundle to different formats bool graphite_export_bundle( const graphite_bundle* bundle, const char* output_path, const graphite_export_config* config ); bool graphite_export_bundle_to_stream( const graphite_bundle* bundle, int (*write_func)(const void* data, size_t size, void* user_data), void* user_data, const graphite_export_config* config ); // Import from supported formats graphite_graph_builder* graphite_import_from_json(const char* json_path); graphite_graph_builder* graphite_import_from_json_string(const char* json_data, size_t json_size); graphite_graph_builder* graphite_import_from_yaml(const char* yaml_path); graphite_graph_builder* graphite_import_from_yaml_string(const char* yaml_data, size_t yaml_size); graphite_graph_builder* graphite_import_from_xml(const char* xml_path); graphite_graph_builder* graphite_import_from_xml_string(const char* xml_data, size_t xml_size); // Convert between GRAPHITE bundle versions bool graphite_convert_bundle_version( const char* input_path, const char* output_path, uint32_t target_version_major, uint32_t target_version_minor ); // Batch conversion utilities typedef struct { const char* input_pattern; // Input file pattern const char* output_directory; // Output directory graphite_export_format format; // Target format bool recursive; // Recursive directory search bool overwrite_existing; // Overwrite existing files uint32_t max_parallel_conversions; // Maximum parallel conversions } graphite_batch_convert_config; uint32_t graphite_batch_convert( const graphite_batch_convert_config* config, void (*progress_callback)(uint32_t completed, uint32_t total, void* user_data), void* user_data ); #ifdef __cplusplus } #endif #endif // GRAPHITE_TOOLING_H ``` --- ## Unity Integration API ### Unity-Specific Integration (graphite_unity.h) The Unity integration provides seamless integration with Unity's asset pipeline and runtime systems: ```c #ifndef GRAPHITE_UNITY_H #define GRAPHITE_UNITY_H #include \"graphite_core.h\" #ifdef __cplusplus extern \"C\" { #endif // Unity-specific asset types typedef enum { UNITY_ASSET_TEXTURE2D, UNITY_ASSET_SPRITE, UNITY_ASSET_MESH, UNITY_ASSET_MATERIAL, UNITY_ASSET_SHADER, UNITY_ASSET_AUDIO_CLIP, UNITY_ASSET_VIDEO_CLIP, UNITY_ASSET_ANIMATION_CLIP, UNITY_ASSET_ANIMATOR_CONTROLLER, UNITY_ASSET_SCRIPT_MONO, UNITY_ASSET_PREFAB, UNITY_ASSET_SCENE, UNITY_ASSET_FONT, UNITY_ASSET_TEXTURE_ARRAY, UNITY_ASSET_RENDER_TEXTURE, UNITY_ASSET_COMPUTE_SHADER, UNITY_ASSET_SCRIPTABLE_OBJECT, } unity_asset_type; // Unity bundle handle typedef struct unity_graphite_bundle unity_graphite_bundle; // Unity-specific loading flags typedef enum { UNITY_LOAD_IMMEDIATE = 0, // Load all assets immediately UNITY_LOAD_STREAMING = 1 << 0, // Enable streaming for large assets UNITY_LOAD_ASYNC = 1 << 1, // Asynchronous loading UNITY_LOAD_EDITOR_ONLY = 1 << 2, // Load editor-only assets UNITY_LOAD_RUNTIME_ONLY = 1 << 3, // Load runtime-only assets UNITY_LOAD_ADDRESSABLE = 1 << 4, // Enable addressable asset system UNITY_LOAD_HOT_RELOAD = 1 << 5, // Enable hot reload for development UNITY_LOAD_MEMORY_OPTIMIZE = 1 << 6, // Optimize for memory usage UNITY_LOAD_MOBILE_OPTIMIZE = 1 << 7, // Optimize for mobile platforms } unity_load_flags; // Unity asset reference typedef struct { unity_asset_type type; // Asset type const char* guid; // Unity GUID const char* path; // Asset path in Unity const graphite_graph* graph; // Underlying graph void* unity_object; // Unity Object reference uint32_t instance_id; // Unity instance ID bool is_loaded; // Whether asset is loaded bool is_streaming; // Whether asset is streaming } unity_asset_ref; // Unity integration context typedef struct { bool editor_mode; // Running in Unity Editor const char* project_path; // Unity project path const char* assets_path; // Unity Assets folder path const char* streaming_assets_path; // StreamingAssets folder path uint32_t unity_version_major; // Unity version uint32_t unity_version_minor; uint32_t unity_version_patch; } unity_integration_context; // // Unity Bundle Management // // Open GRAPHITE bundle for Unity unity_graphite_bundle* unity_graphite_open( const char* file_path, uint32_t unity_flags, const unity_integration_context* context ); // Load from StreamingAssets unity_graphite_bundle* unity_graphite_open_streaming_asset( const char* relative_path, uint32_t unity_flags ); // Load with Unity's WWW/UnityWebRequest unity_graphite_bundle* unity_graphite_open_from_url( const char* url, uint32_t unity_flags ); // Close Unity bundle void unity_graphite_close(unity_graphite_bundle* bundle); // // Unity Asset Loading // // Load Unity asset from graph void* unity_graphite_load_asset( unity_graphite_bundle* bundle, const graphite_graph* asset_graph, unity_asset_type expected_type ); // Load asset by path void* unity_graphite_load_asset_by_path( unity_graphite_bundle* bundle, const char* asset_path, unity_asset_type expected_type ); // Load asset by GUID void* unity_graphite_load_asset_by_guid( unity_graphite_bundle* bundle, const char* guid, unity_asset_type expected_type ); // Asynchronous asset loading typedef struct unity_async_operation unity_async_operation; typedef void (*unity_asset_loaded_callback)( void* asset, unity_asset_type type, bool success, void* user_data ); unity_async_operation* unity_graphite_load_asset_async( unity_graphite_bundle* bundle, const graphite_graph* asset_graph, unity_asset_type expected_type, unity_asset_loaded_callback callback, void* user_data ); bool unity_async_operation_is_done(unity_async_operation* operation); float unity_async_operation_get_progress(unity_async_operation* operation); void unity_async_operation_cancel(unity_async_operation* operation); void unity_async_operation_destroy(unity_async_operation* operation); // // Unity Asset Type Conversions // // Convert GRAPHITE graph to Unity Texture2D void* unity_graphite_create_texture2d( const graphite_graph* asset_graph, bool mip_chain, bool linear ); // Convert to Unity Mesh void* unity_graphite_create_mesh(const graphite_graph* asset_graph); // Convert to Unity AudioClip void* unity_graphite_create_audio_clip( const graphite_graph* asset_graph, bool stream_from_disk ); // Convert to Unity Material void* unity_graphite_create_material( const graphite_graph* asset_graph, void* shader ); // Convert to Unity Sprite void* unity_graphite_create_sprite( const graphite_graph* asset_graph, float pixels_per_unit, uint32_t extrude, uint32_t mesh_type ); // // Unity ScriptableObject Integration // // Create ScriptableObject from GRAPHITE data void* unity_graphite_create_scriptable_object( const graphite_graph* asset_graph, const char* type_name ); // Serialize Unity object to GRAPHITE graphite_graph_builder* unity_graphite_serialize_object( void* unity_object, bool include_references ); // // Unity Asset Database Integration // // Register GRAPHITE bundle with AssetDatabase bool unity_graphite_register_bundle( unity_graphite_bundle* bundle, const char* asset_database_path ); // Import GRAPHITE assets into AssetDatabase uint32_t unity_graphite_import_assets( unity_graphite_bundle* bundle, const char* import_path, bool overwrite_existing ); // Create Unity AssetBundle from GRAPHITE bundle bool unity_graphite_create_asset_bundle( unity_graphite_bundle* graphite_bundle, const char* output_path, uint32_t build_flags ); // // Unity Addressable Asset System Integration // // Register assets as addressable bool unity_graphite_register_addressable_assets( unity_graphite_bundle* bundle, const char* group_name ); // Load addressable asset from GRAPHITE unity_async_operation* unity_graphite_load_addressable_asset( const char* address, unity_asset_loaded_callback callback, void* user_data ); // // Unity Editor Integration // #ifdef UNITY_EDITOR // Unity Editor-specific functions // Custom asset importer for .graphite files typedef struct { bool import_as_streaming_asset; // Import to StreamingAssets bool generate_addressable_entries; // Generate addressable entries bool create_asset_references; // Create Unity asset references unity_asset_type default_asset_type; // Default asset type for unknown content const char* import_path_prefix; // Prefix for imported asset paths } unity_import_settings; bool unity_graphite_import_bundle_editor( const char* graphite_file_path, const unity_import_settings* settings ); // Asset post-processor integration void unity_graphite_on_postprocess_all_assets( const char** imported_assets, uint32_t imported_count, const char** deleted_assets, uint32_t deleted_count, const char** moved_assets, uint32_t moved_count, const char** moved_from_assets, uint32_t moved_from_count ); // Build pipeline integration typedef struct { const char* target_platform; // Build target platform bool development_build; // Development build flag bool compress_bundles; // Compress GRAPHITE bundles bool strip_debug_data; // Strip debug information const char* output_directory; // Build output directory } unity_build_context; bool unity_graphite_on_build_process( const unity_build_context* context, const char** graphite_bundles, uint32_t bundle_count ); // Custom property drawer for GRAPHITE references typedef struct { const char* property_path; // Property path in inspector const graphite_graph* referenced_graph; // Referenced graph unity_asset_type asset_type; // Expected asset type bool allow_scene_objects; // Allow scene object references } unity_graphite_property_drawer; void unity_graphite_draw_property( unity_graphite_property_drawer* drawer, void* property, void* label ); #endif // UNITY_EDITOR // // Unity Performance Integration // // Profiler integration void unity_graphite_begin_profiler_sample(const char* sample_name); void unity_graphite_end_profiler_sample(void); // Memory profiler integration void unity_graphite_register_memory_usage( unity_graphite_bundle* bundle, size_t memory_size, const char* category ); // GPU profiler integration void unity_graphite_register_gpu_memory_usage( void* unity_object, size_t gpu_memory_size ); // // Unity Platform-Specific Optimizations // // Mobile platform optimizations void unity_graphite_optimize_for_mobile(unity_graphite_bundle* bundle); // Console platform optimizations void unity_graphite_optimize_for_console( unity_graphite_bundle* bundle, const char* console_platform ); // VR/AR platform optimizations void unity_graphite_optimize_for_xr(unity_graphite_bundle* bundle); // // Unity Event System Integration // // Unity event callbacks typedef void (*unity_bundle_loaded_callback)(unity_graphite_bundle* bundle, void* user_data); typedef void (*unity_asset_loaded_callback_ex)( void* asset, unity_asset_type type, const char* path, bool success, void* user_data ); typedef void (*unity_bundle_error_callback)( unity_graphite_bundle* bundle, graphite_error error, const char* error_message, void* user_data ); void unity_graphite_set_bundle_loaded_callback( unity_bundle_loaded_callback callback, void* user_data ); void unity_graphite_set_asset_loaded_callback( unity_asset_loaded_callback_ex callback, void* user_data ); void unity_graphite_set_error_callback( unity_bundle_error_callback callback, void* user_data ); // // Unity Coroutine Integration // // Start coroutine for asset loading void* unity_graphite_start_load_coroutine( unity_graphite_bundle* bundle, const char* asset_path, unity_asset_type asset_type ); // Yield instruction for waiting on GRAPHITE operations void* unity_graphite_create_wait_for_load(unity_async_operation* operation); // // Unity Utility Functions // // Get Unity version compatibility bool unity_graphite_is_compatible_version( uint32_t unity_major, uint32_t unity_minor, uint32_t unity_patch ); // Convert Unity asset type to MIME type const char* unity_graphite_asset_type_to_mime_type(unity_asset_type type); // Convert MIME type to Unity asset type unity_asset_type unity_graphite_mime_type_to_asset_type(const char* mime_type); // Get Unity object type name const char* unity_graphite_get_unity_type_name(unity_asset_type type); // Validate Unity asset bool unity_graphite_validate_unity_asset( void* unity_object, unity_asset_type expected_type ); #ifdef __cplusplus } #endif #endif // GRAPHITE_UNITY_H ``` --- ## Unreal Engine Integration API ### Unreal Engine Integration (graphite_unreal.h) The Unreal Engine integration provides comprehensive support for Unreal's asset system and runtime: ```c #ifndef GRAPHITE_UNREAL_H #define GRAPHITE_UNREAL_H #include \"graphite_core.h\" #ifdef __cplusplus extern \"C\" { #endif // Unreal Engine asset types typedef enum { UNREAL_ASSET_TEXTURE2D, UNREAL_ASSET_STATIC_MESH, UNREAL_ASSET_SKELETAL_MESH, UNREAL_ASSET_MATERIAL, UNREAL_ASSET_MATERIAL_INSTANCE, UNREAL_ASSET_SOUND_WAVE, UNREAL_ASSET_SOUND_CUE, UNREAL_ASSET_ANIMATION_SEQUENCE, UNREAL_ASSET_ANIMATION_BLUEPRINT, UNREAL_ASSET_BLUEPRINT, UNREAL_ASSET_LEVEL, UNREAL_ASSET_WORLD, UNREAL_ASSET_PARTICLE_SYSTEM, UNREAL_ASSET_NIAGARA_SYSTEM, UNREAL_ASSET_WIDGET_BLUEPRINT, UNREAL_ASSET_DATA_TABLE, UNREAL_ASSET_CURVE_TABLE, UNREAL_ASSET_STRING_TABLE, UNREAL_ASSET_FONT, UNREAL_ASSET_TEXTURE_RENDER_TARGET, UNREAL_ASSET_MEDIA_SOURCE, UNREAL_ASSET_SUBSURFACE_PROFILE, } unreal_asset_type; // Unreal bundle handle typedef struct unreal_graphite_bundle unreal_graphite_bundle; // Unreal-specific loading flags typedef enum { UNREAL_LOAD_IMMEDIATE = 0, // Load all assets immediately UNREAL_LOAD_STREAMING = 1 << 0, // Enable streaming for large assets UNREAL_LOAD_ASYNC = 1 << 1, // Asynchronous loading UNREAL_LOAD_EDITOR_ONLY = 1 << 2, // Load editor-only assets UNREAL_LOAD_GAME_ONLY = 1 << 3, // Load game-only assets UNREAL_LOAD_DEDICATED_SERVER = 1 << 4, // Load dedicated server assets UNREAL_LOAD_MOBILE_OPTIMIZE = 1 << 5, // Optimize for mobile platforms UNREAL_LOAD_CONSOLE_OPTIMIZE = 1 << 6, // Optimize for console platforms UNREAL_LOAD_VR_OPTIMIZE = 1 << 7, // Optimize for VR platforms } unreal_load_flags; // Unreal asset reference typedef struct { unreal_asset_type type; // Asset type const char* package_name; // Unreal package name const char* asset_name; // Asset name const char* object_path; // Full object path const graphite_graph* graph; // Underlying graph void* unreal_object; // UObject reference bool is_loaded; // Whether asset is loaded bool is_streaming; // Whether asset is streaming uint32_t memory_usage; // Memory usage in bytes } unreal_asset_ref; // Unreal integration context typedef struct { bool editor_mode; // Running in Unreal Editor const char* project_path; // Unreal project path const char* content_path; // Content folder path uint32_t engine_version_major; // Unreal Engine version uint32_t engine_version_minor; uint32_t engine_version_patch; const char* target_platform; // Target platform bool is_dedicated_server; // Running as dedicated server } unreal_integration_context; // // Unreal Bundle Management // // Open GRAPHITE bundle for Unreal unreal_graphite_bundle* unreal_graphite_open( const char* file_path, uint32_t unreal_flags, const unreal_integration_context* context ); // Load from Content directory unreal_graphite_bundle* unreal_graphite_open_content_asset( const char* relative_path, uint32_t unreal_flags ); // Load from pak file unreal_graphite_bundle* unreal_graphite_open_from_pak( const char* pak_file_path, const char* internal_path, uint32_t unreal_flags ); // Close Unreal bundle void unreal_graphite_close(unreal_graphite_bundle* bundle); // // Unreal Asset Loading // // Load Unreal asset from graph void* unreal_graphite_load_asset( unreal_graphite_bundle* bundle, const graphite_graph* asset_graph, unreal_asset_type expected_type ); // Load asset by object path void* unreal_graphite_load_asset_by_path( unreal_graphite_bundle* bundle, const char* object_path, unreal_asset_type expected_type ); // Load asset by package and name void* unreal_graphite_load_asset_by_name( unreal_graphite_bundle* bundle, const char* package_name, const char* asset_name, unreal_asset_type expected_type ); // Asynchronous asset loading with Unreal's async system typedef struct unreal_async_handle unreal_async_handle; typedef void (*unreal_asset_loaded_callback)( void* asset, unreal_asset_type type, bool success, void* user_data ); unreal_async_handle* unreal_graphite_load_asset_async( unreal_graphite_bundle* bundle, const graphite_graph* asset_graph, unreal_asset_type expected_type, unreal_asset_loaded_callback callback, void* user_data ); bool unreal_async_handle_is_complete(unreal_async_handle* handle); float unreal_async_handle_get_progress(unreal_async_handle* handle); void unreal_async_handle_cancel(unreal_async_handle* handle); void unreal_async_handle_destroy(unreal_async_handle* handle); // // Unreal Asset Type Conversions // // Convert GRAPHITE graph to Unreal Texture2D void* unreal_graphite_create_texture2d( const graphite_graph* asset_graph, bool generate_mips, uint32_t compression_settings ); // Convert to Unreal Static Mesh void* unreal_graphite_create_static_mesh( const graphite_graph* asset_graph, bool build_collision ); // Convert to Unreal Skeletal Mesh void* unreal_graphite_create_skeletal_mesh( const graphite_graph* asset_graph, void* skeleton ); // Convert to Unreal Sound Wave void* unreal_graphite_create_sound_wave( const graphite_graph* asset_graph, bool compress_audio ); // Convert to Unreal Material void* unreal_graphite_create_material( const graphite_graph* asset_graph, const char* material_domain ); // Convert to Unreal Animation Sequence void* unreal_graphite_create_animation_sequence( const graphite_graph* asset_graph, void* skeleton ); // // Unreal Content Browser Integration // // Register GRAPHITE bundle with Content Browser bool unreal_graphite_register_bundle( unreal_graphite_bundle* bundle, const char* virtual_path ); // Import GRAPHITE assets into Content Browser uint32_t unreal_graphite_import_assets( unreal_graphite_bundle* bundle, const char* import_path, bool overwrite_existing ); // Create Unreal Asset Registry entries bool unreal_graphite_create_registry_entries( unreal_graphite_bundle* bundle, const char* base_package_path ); // // Unreal Asset Streaming Integration // // Register with Unreal's streaming system bool unreal_graphite_register_streaming_assets( unreal_graphite_bundle* bundle, uint32_t streaming_priority ); // Set streaming distance for assets void unreal_graphite_set_streaming_distance( unreal_graphite_bundle* bundle, float streaming_distance ); // Manual streaming control bool unreal_graphite_request_streaming_load( unreal_graphite_bundle* bundle, const char* asset_path ); bool unreal_graphite_request_streaming_unload( unreal_graphite_bundle* bundle, const char* asset_path ); // // Unreal World Partition Integration // // Register assets for World Partition bool unreal_graphite_register_world_partition_assets( unreal_graphite_bundle* bundle, const char* world_name ); // Create streaming source for World Partition void* unreal_graphite_create_streaming_source( unreal_graphite_bundle* bundle, float x, float y, float z, float radius ); // // Unreal Editor Integration // #ifdef WITH_EDITOR // Unreal Editor-specific functions // Custom asset factory for .graphite files typedef struct { bool import_to_content; // Import to Content directory bool create_asset_references; // Create Unreal asset references unreal_asset_type default_asset_type; // Default asset type for unknown content const char* import_package_path; // Package path for imported assets bool auto_reimport; // Enable auto-reimport } unreal_import_settings; bool unreal_graphite_import_bundle_editor( const char* graphite_file_path, const unreal_import_settings* settings ); // Asset thumbnail provider void* unreal_graphite_create_asset_thumbnail( const graphite_graph* asset_graph, uint32_t width, uint32_t height ); // Property customization for GRAPHITE references typedef struct { const char* property_name; // Property name in details panel const graphite_graph* referenced_graph; // Referenced graph unreal_asset_type asset_type; // Expected asset type bool allow_clear; // Allow clearing reference } unreal_graphite_property_customization; void unreal_graphite_customize_property( unreal_graphite_property_customization* customization, void* property_handle ); // Asset actions for GRAPHITE bundles void unreal_graphite_register_asset_actions(void); // Commandlet for batch processing int32_t unreal_graphite_commandlet_main( const char** args, uint32_t arg_count ); #endif // WITH_EDITOR // // Unreal Rendering Integration // // Material parameter binding bool unreal_graphite_bind_material_parameters( void* material_instance, const graphite_graph* parameter_graph ); // Texture streaming void unreal_graphite_set_texture_streaming_priority( void* texture, int32_t priority ); // Mesh LOD integration bool unreal_graphite_set_mesh_lod_settings( void* static_mesh, const graphite_graph* lod_settings_graph ); // // Unreal Audio Integration // // Sound attenuation settings void unreal_graphite_apply_sound_attenuation( void* sound_wave, const graphite_graph* attenuation_graph ); // Audio compression settings void unreal_graphite_set_audio_compression( void* sound_wave, const char* compression_type, float quality ); // // Unreal Animation Integration // // Animation curve binding bool unreal_graphite_bind_animation_curves( void* animation_sequence, const graphite_graph* curve_graph ); // Animation notify integration bool unreal_graphite_add_animation_notifies( void* animation_sequence, const graphite_graph* notify_graph ); // // Unreal Performance Integration // // Stats integration void unreal_graphite_begin_stats_scope(const char* stat_name); void unreal_graphite_end_stats_scope(void); // Memory tracking void unreal_graphite_track_memory_usage( unreal_graphite_bundle* bundle, size_t memory_size, const char* category ); // GPU memory tracking void unreal_graphite_track_gpu_memory_usage( void* unreal_object, size_t gpu_memory_size ); // Cook stats integration void unreal_graphite_log_cook_stats( const char* asset_name, uint64_t cook_time_ms, size_t cooked_size, size_t original_size ); // // Unreal Platform Integration // // Platform-specific asset variants void* unreal_graphite_load_platform_asset( unreal_graphite_bundle* bundle, const char* asset_path, const char* platform_name ); // Platform compression void unreal_graphite_apply_platform_compression( unreal_graphite_bundle* bundle, const char* platform_name ); // Platform texture settings void unreal_graphite_apply_platform_texture_settings( void* texture, const char* platform_name ); // // Unreal Event System Integration // // Unreal delegate callbacks typedef void (*unreal_bundle_loaded_delegate)(unreal_graphite_bundle* bundle, void* user_data); typedef void (*unreal_asset_loaded_delegate)( void* asset, unreal_asset_type type, const char* path, bool success, void* user_data ); typedef void (*unreal_bundle_error_delegate)( unreal_graphite_bundle* bundle, graphite_error error, const char* error_message, void* user_data ); void unreal_graphite_bind_bundle_loaded_delegate( unreal_bundle_loaded_delegate delegate, void* user_data ); void unreal_graphite_bind_asset_loaded_delegate( unreal_asset_loaded_delegate delegate, void* user_data ); void unreal_graphite_bind_error_delegate( unreal_bundle_error_delegate delegate, void* user_data ); // // Unreal Blueprint Integration // // Blueprint function library functions bool unreal_graphite_blueprint_load_bundle(const char* file_path); void* unreal_graphite_blueprint_load_asset(const char* asset_path, const char* asset_type); bool unreal_graphite_blueprint_is_asset_loaded(const char* asset_path); void unreal_graphite_blueprint_unload_asset(const char* asset_path); // Blueprint events void unreal_graphite_blueprint_on_bundle_loaded(const char* bundle_path); void unreal_graphite_blueprint_on_asset_loaded(const char* asset_path, bool success); void unreal_graphite_blueprint_on_loading_error(const char* error_message); // // Unreal Utility Functions // // Get Unreal Engine version compatibility bool unreal_graphite_is_compatible_version( uint32_t ue_major, uint32_t ue_minor, uint32_t ue_patch ); // Convert Unreal asset type to MIME type const char* unreal_graphite_asset_type_to_mime_type(unreal_asset_type type); // Convert MIME type to Unreal asset type unreal_asset_type unreal_graphite_mime_type_to_asset_type(const char* mime_type); // Get Unreal class name const char* unreal_graphite_get_unreal_class_name(unreal_asset_type type); // Validate Unreal object bool unreal_graphite_validate_unreal_object( void* unreal_object, unreal_asset_type expected_type ); // Convert Unreal FString to C string const char* unreal_graphite_fstring_to_cstring(void* fstring); // Convert C string to Unreal FString void* unreal_graphite_cstring_to_fstring(const char* cstring); #ifdef __cplusplus } #endif #endif // GRAPHITE_UNREAL_H ``` --- ## Godot Integration API ### Godot Engine Integration (graphite_godot.h) The Godot integration provides native support for Godot's resource system and scene management: ```c #ifndef GRAPHITE_GODOT_H #define GRAPHITE_GODOT_H #include \"graphite_core.h\" #ifdef __cplusplus extern \"C\" { #endif // Godot resource types typedef enum { GODOT_RESOURCE_TEXTURE2D, GODOT_RESOURCE_TEXTURE3D, GODOT_RESOURCE_TEXTURE_ARRAY, GODOT_RESOURCE_CUBEMAP, GODOT_RESOURCE_MESH, GODOT_RESOURCE_MATERIAL, GODOT_RESOURCE_SHADER, GODOT_RESOURCE_AUDIO_STREAM, GODOT_RESOURCE_VIDEO_STREAM, GODOT_RESOURCE_ANIMATION, GODOT_RESOURCE_SCENE, GODOT_RESOURCE_PACKED_SCENE, GODOT_RESOURCE_SCRIPT, GODOT_RESOURCE_FONT, GODOT_RESOURCE_THEME, GODOT_RESOURCE_ENVIRONMENT, GODOT_RESOURCE_WORLD_3D, GODOT_RESOURCE_WORLD_2D, GODOT_RESOURCE_CURVE, GODOT_RESOURCE_GRADIENT, GODOT_RESOURCE_PARTICLE_MATERIAL, } godot_resource_type; // Godot bundle handle typedef struct godot_graphite_bundle godot_graphite_bundle; // Godot-specific loading flags typedef enum { GODOT_LOAD_IMMEDIATE = 0, // Load all resources immediately GODOT_LOAD_STREAMING = 1 << 0, // Enable streaming for large resources GODOT_LOAD_ASYNC = 1 << 1, // Asynchronous loading GODOT_LOAD_EDITOR_ONLY = 1 << 2, // Load editor-only resources GODOT_LOAD_GAME_ONLY = 1 << 3, // Load game-only resources GODOT_LOAD_DEBUG_ONLY = 1 << 4, // Load debug-only resources GODOT_LOAD_MOBILE_OPTIMIZE = 1 << 5, // Optimize for mobile platforms GODOT_LOAD_WEB_OPTIMIZE = 1 << 6, // Optimize for web platforms GODOT_LOAD_CACHE_RESOURCES = 1 << 7, // Cache resources in memory } godot_load_flags; // Godot resource reference typedef struct { godot_resource_type type; // Resource type const char* resource_path; // Godot resource path const char* class_name; // Godot class name const graphite_graph* graph; // Underlying graph void* godot_resource; // Godot Resource reference bool is_loaded; // Whether resource is loaded bool is_streaming; // Whether resource is streaming uint32_t reference_count; // Reference count } godot_resource_ref; // Godot integration context typedef struct { bool editor_mode; // Running in Godot Editor const char* project_path; // Godot project path const char* res_path; // res:// folder path const char* user_path; // user:// folder path uint32_t godot_version_major; // Godot version uint32_t godot_version_minor; uint32_t godot_version_patch; const char* target_platform; // Target platform bool is_debug_build; // Debug build flag } godot_integration_context; // // Godot Bundle Management // // Open GRAPHITE bundle for Godot godot_graphite_bundle* godot_graphite_open( const char* file_path, uint32_t godot_flags, const godot_integration_context* context ); // Load from res:// directory godot_graphite_bundle* godot_graphite_open_resource( const char* resource_path, uint32_t godot_flags ); // Load from user:// directory godot_graphite_bundle* godot_graphite_open_user_resource( const char* user_path, uint32_t godot_flags ); // Close Godot bundle void godot_graphite_close(godot_graphite_bundle* bundle); // // Godot Resource Loading // // Load Godot resource from graph void* godot_graphite_load_resource( godot_graphite_bundle* bundle, const graphite_graph* resource_graph, godot_resource_type expected_type ); // Load resource by path void* godot_graphite_load_resource_by_path( godot_graphite_bundle* bundle, const char* resource_path, godot_resource_type expected_type ); // Load resource by class name void* godot_graphite_load_resource_by_class( godot_graphite_bundle* bundle, const char* class_name, godot_resource_type expected_type ); // Asynchronous resource loading typedef struct godot_async_loader godot_async_loader; typedef void (*godot_resource_loaded_callback)( void* resource, godot_resource_type type, bool success, void* user_data ); godot_async_loader* godot_graphite_load_resource_async( godot_graphite_bundle* bundle, const graphite_graph* resource_graph, godot_resource_type expected_type, godot_resource_loaded_callback callback, void* user_data ); bool godot_async_loader_is_complete(godot_async_loader* loader); float godot_async_loader_get_progress(godot_async_loader* loader); void godot_async_loader_cancel(godot_async_loader* loader); void godot_async_loader_destroy(godot_async_loader* loader); // // Godot Resource Type Conversions // // Convert GRAPHITE graph to Godot ImageTexture void* godot_graphite_create_image_texture( const graphite_graph* resource_graph, bool generate_mipmaps ); // Convert to Godot ArrayMesh void* godot_graphite_create_array_mesh(const graphite_graph* resource_graph); // Convert to Godot StandardMaterial3D void* godot_graphite_create_standard_material(const graphite_graph* resource_graph); // Convert to Godot AudioStreamOggVorbis void* godot_graphite_create_audio_stream_ogg(const graphite_graph* resource_graph); // Convert to Godot AudioStreamWAV void* godot_graphite_create_audio_stream_wav(const graphite_graph* resource_graph); // Convert to Godot PackedScene void* godot_graphite_create_packed_scene(const graphite_graph* resource_graph); // Convert to Godot Animation void* godot_graphite_create_animation(const graphite_graph* resource_graph); // // Godot Resource Manager Integration // // Register GRAPHITE bundle with ResourceLoader bool godot_graphite_register_bundle( godot_graphite_bundle* bundle, const char* virtual_path ); // Import GRAPHITE resources into project uint32_t godot_graphite_import_resources( godot_graphite_bundle* bundle, const char* import_path, bool overwrite_existing ); // Create Godot resource files from GRAPHITE bool godot_graphite_create_resource_files( godot_graphite_bundle* bundle, const char* output_directory ); // // Godot Scene Tree Integration // // Instantiate scene from GRAPHITE void* godot_graphite_instantiate_scene( godot_graphite_bundle* bundle, const graphite_graph* scene_graph ); // Add resources to scene bool godot_graphite_add_resources_to_scene( void* scene_tree, godot_graphite_bundle* bundle ); // Create node hierarchy from graph void* godot_graphite_create_node_hierarchy( const graphite_graph* hierarchy_graph, void* parent_node ); // // Godot Editor Integration // #ifdef TOOLS_ENABLED // Godot Editor-specific functions // Custom resource importer for .graphite files typedef struct { bool import_to_res; // Import to res:// directory bool create_resource_files; // Create .tres/.res files godot_resource_type default_resource_type; // Default resource type const char* import_path_prefix; // Prefix for imported resource paths bool auto_reload; // Enable auto-reload } godot_import_settings; bool godot_graphite_import_bundle_editor( const char* graphite_file_path, const godot_import_settings* settings ); // Editor plugin integration void godot_graphite_register_editor_plugin(void); // Custom dock for GRAPHITE management void* godot_graphite_create_editor_dock(void); // Inspector plugin for GRAPHITE properties void godot_graphite_register_inspector_plugin(void); // Resource picker integration void* godot_graphite_create_resource_picker(godot_resource_type resource_type); #endif // TOOLS_ENABLED // // Godot Export Integration // // Export template integration bool godot_graphite_register_export_plugin(void); // Platform-specific export bool godot_graphite_export_for_platform( godot_graphite_bundle* bundle, const char* platform_name, const char* output_path ); // PCK file integration bool godot_graphite_add_to_pck( godot_graphite_bundle* bundle, const char* pck_file_path ); // // Godot Streaming Integration // // Register with Godot's resource streaming system bool godot_graphite_register_streaming_resources( godot_graphite_bundle* bundle ); // Set streaming priority void godot_graphite_set_streaming_priority( godot_graphite_bundle* bundle, const char* resource_path, int32_t priority ); // Request streaming load/unload bool godot_graphite_request_streaming_load( godot_graphite_bundle* bundle, const char* resource_path ); bool godot_graphite_request_streaming_unload( godot_graphite_bundle* bundle, const char* resource_path ); // // Godot Rendering Integration // // Material property binding bool godot_graphite_bind_material_properties( void* material, const graphite_graph* property_graph ); // Shader parameter binding bool godot_graphite_bind_shader_parameters( void* shader_material, const graphite_graph* parameter_graph ); // Environment settings void* godot_graphite_create_environment(const graphite_graph* environment_graph); // // Godot Audio Integration // // Audio bus integration bool godot_graphite_configure_audio_bus( const char* bus_name, const graphite_graph* bus_config_graph ); // Audio effect integration void* godot_graphite_create_audio_effect( const graphite_graph* effect_graph, const char* effect_type ); // // Godot Animation Integration // // Animation player integration bool godot_graphite_setup_animation_player( void* animation_player, godot_graphite_bundle* bundle ); // Animation tree integration bool godot_graphite_setup_animation_tree( void* animation_tree, const graphite_graph* tree_graph ); // Tween integration void* godot_graphite_create_tween(const graphite_graph* tween_graph); // // Godot Physics Integration // // Physics material creation void* godot_graphite_create_physics_material(const graphite_graph* material_graph); // Collision shape creation void* godot_graphite_create_collision_shape( const graphite_graph* shape_graph, const char* shape_type ); // // Godot Input Integration // // Input map integration bool godot_graphite_configure_input_map( const graphite_graph* input_map_graph ); // Custom input events void* godot_graphite_create_input_event( const graphite_graph* event_graph, const char* event_type ); // // Godot Signal System Integration // // Signal connection from graph data bool godot_graphite_connect_signals( void* source_node, void* target_node, const graphite_graph* signal_graph ); // Custom signal definitions bool godot_graphite_define_custom_signals( void* object, const graphite_graph* signal_definitions ); // // Godot Performance Integration // // Profiler integration void godot_graphite_begin_profiler_frame(const char* frame_name); void godot_graphite_end_profiler_frame(void); // Memory usage tracking void godot_graphite_track_memory_usage( godot_graphite_bundle* bundle, size_t memory_size, const char* category ); // Performance monitoring typedef struct { uint64_t frame_time_ns; // Frame processing time uint32_t resources_loaded; // Resources loaded this frame size_t memory_used; // Memory used by resources uint32_t draw_calls; // Additional draw calls } godot_performance_stats; godot_performance_stats godot_graphite_get_performance_stats( godot_graphite_bundle* bundle ); // // Godot Platform Integration // // Mobile platform optimizations void godot_graphite_optimize_for_mobile(godot_graphite_bundle* bundle); // Web platform optimizations void godot_graphite_optimize_for_web(godot_graphite_bundle* bundle); // Console platform optimizations void godot_graphite_optimize_for_console( godot_graphite_bundle* bundle, const char* console_platform ); // // Godot Event System Integration // // Godot signal callbacks typedef void (*godot_bundle_loaded_signal)(godot_graphite_bundle* bundle, void* user_data); typedef void (*godot_resource_loaded_signal)( void* resource, godot_resource_type type, const char* path, bool success, void* user_data ); typedef void (*godot_bundle_error_signal)( godot_graphite_bundle* bundle, graphite_error error, const char* error_message, void* user_data ); void godot_graphite_connect_bundle_loaded_signal( godot_bundle_loaded_signal signal_callback, void* user_data ); void godot_graphite_connect_resource_loaded_signal( godot_resource_loaded_signal signal_callback, void* user_data ); void godot_graphite_connect_error_signal( godot_bundle_error_signal signal_callback, void* user_data ); // // Godot GDScript Integration // // GDScript class registration bool godot_graphite_register_gdscript_class(const char* class_name); // GDScript method binding bool godot_graphite_bind_gdscript_methods(void); // GDScript property binding bool godot_graphite_bind_gdscript_properties(void); // GDScript signal binding bool godot_graphite_bind_gdscript_signals(void); // // Godot Utility Functions // // Get Godot version compatibility bool godot_graphite_is_compatible_version( uint32_t godot_major, uint32_t godot_minor, uint32_t godot_patch ); // Convert Godot resource type to MIME type const char* godot_graphite_resource_type_to_mime_type(godot_resource_type type); // Convert MIME type to Godot resource type godot_resource_type godot_graphite_mime_type_to_resource_type(const char* mime_type); // Get Godot class name const char* godot_graphite_get_godot_class_name(godot_resource_type type); // Validate Godot resource bool godot_graphite_validate_godot_resource( void* godot_resource, godot_resource_type expected_type ); // Convert Godot String to C string const char* godot_graphite_string_to_cstring(void* godot_string); // Convert C string to Godot String void* godot_graphite_cstring_to_string(const char* cstring); // Convert Godot Variant to property value bool godot_graphite_variant_to_property_value( void* variant, graphite_property_value* property_value ); // Convert property value to Godot Variant void* godot_graphite_property_value_to_variant( const graphite_property_value* property_value ); #ifdef __cplusplus } #endif #endif // GRAPHITE_GODOT_H ``` --- ## Command Line Interface ### GRAPHITE CLI Tool Specification The GRAPHITE command-line interface provides comprehensive tooling for bundle creation, analysis, and manipulation: #### Core CLI Commands ```bash # Basic bundle operations graphite info <bundle.graphite> # Display bundle information graphite validate <bundle.graphite> # Validate bundle integrity graphite pack <input_dir> <output.graphite> # Create bundle from directory graphite unpack <bundle.graphite> <output_dir> # Extract bundle to directory graphite convert <input> <output> --format=<fmt> # Convert between formats # Analysis and optimization graphite analyze <bundle.graphite> # Analyze bundle performance graphite optimize <bundle.graphite> # Optimize bundle graphite benchmark <bundle.graphite> # Performance benchmark graphite diff <bundle1.graphite> <bundle2.graphite> # Compare bundles # Compression and integrity graphite compress <bundle.graphite> # Compress bundle graphite decompress <bundle.graphite> # Decompress bundle graphite sign <bundle.graphite> --key=<keyfile> # Sign bundle graphite verify <bundle.graphite> --key=<keyfile> # Verify signature # Development and debugging graphite trace <bundle.graphite> # Trace bundle loading graphite profile <bundle.graphite> # Profile performance graphite test <bundle.graphite> # Run test suite graphite repair <bundle.graphite> # Repair corrupted bundle ``` #### Detailed Command Specifications ##### 1. Bundle Information (`graphite info`) ```bash # Basic information graphite info assets.graphite # Detailed analysis with statistics graphite info assets.graphite --detailed # JSON output for scripting graphite info assets.graphite --format=json # Filter specific information graphite info assets.graphite --show=size,compression,integrity # Compare with other bundle graphite info assets.graphite --compare=assets_old.graphite Example Output: =============== GRAPHITE Bundle Information =============== File: assets.graphite Format Version: 0.1.0 File Size: 142.8 MB (149,758,976 bytes) Created: 2025-06-28T10:30:15Z Modified: 2025-06-28T11:45:22Z Structure: Chunks: 1,247 (987 graphs, 260 blobs) Nodes: 15,632 total Edges: 8,941 total Properties: 42,157 total Max Depth: 8 levels Content: Image Assets: 324 (89.2 MB) Audio Assets: 156 (31.7 MB) Mesh Assets: 78 (18.4 MB) Script Assets: 429 (3.5 MB) Compression: Compressed Chunks: 856 (68.6%) Compression Ratio: 3.2:1 Estimated Decompression Time: 45ms Integrity: Hash Tree: Present (BLAKE3) Protected Chunks: 1,247 (100%) Verification Time: 23ms Digital Signature: Present (Ed25519) Performance Estimates: Sequential Load Time: 89ms Parallel Load Time: 34ms Memory Usage: 89.7 MB Cache Hit Ratio: 94% ``` ##### 2. Bundle Validation (`graphite validate`) ```bash # Quick validation graphite validate assets.graphite # Comprehensive validation graphite validate assets.graphite --level=thorough # Validation with repair suggestions graphite validate assets.graphite --suggest-repairs # Batch validation graphite validate *.graphite --parallel # Validation with custom rules graphite validate assets.graphite --rules=validation_rules.json Example Output: =============== GRAPHITE Bundle Validation =============== File: assets.graphite Validation Level: Standard Validation Time: 156ms ‚úì File Format: Valid ‚úì Header Integrity: Valid ‚úì Chunk Table: Valid ‚úì Graph Structure: Valid ‚úì Property Types: Valid ‚úì String References: Valid ‚úì Cross References: Valid ‚úì Hash Tree: Valid ‚úì Signatures: Valid Warnings (2): - Chunk 0x4A7: Compression ratio below optimal (0.87, recommended <0.8) - String Pool: 23 unused strings detected (0.3% waste) Performance Analysis: Load Time Estimate: 67ms (Excellent) Memory Efficiency: 89% (Good) Cache Locality: 94% (Excellent) Parallelization: 87% (Good) Recommendations: 1. Recompress chunk 0x4A7 with higher compression level 2. Remove unused strings to save 1.2KB 3. Consider reordering chunks for better locality Overall Result: VALID (2 warnings) ``` ##### 3. Bundle Creation (`graphite pack`) ```bash # Basic bundle creation graphite pack assets/ game_assets.graphite # With compression graphite pack assets/ game_assets.graphite --compress --level=5 # With integrity verification graphite pack assets/ game_assets.graphite --integrity --sign=private_key.pem # With advanced options graphite pack assets/ game_assets.graphite \\ --compress \\ --level=7 \\ --dictionary \\ --integrity \\ --parallel=8 \\ --metadata=bundle_metadata.json \\ --exclude=\"*.tmp,*.bak\" \\ --include-pattern=\"*.png,*.jpg,*.ogg,*.fbx\" # Progressive build with caching graphite pack assets/ game_assets.graphite \\ --incremental \\ --cache-dir=.graphite_cache \\ --changed-since=\"2025-06-27T00:00:00Z\" # Content-aware optimization graphite pack assets/ game_assets.graphite \\ --optimize \\ --target-platform=mobile \\ --quality=high \\ --memory-limit=512MB Example Output: =============== GRAPHITE Bundle Creation =============== Input Directory: assets/ Output Bundle: game_assets.graphite Compression: zstd level 7 Dictionary Training: Enabled Integrity: BLAKE3 + Ed25519 signature Parallel Threads: 8 Scanning input directory... Found 1,847 files (156.3 MB total) Content Analysis: Images: 456 files (89.7 MB) ‚Üí zstd-5 + dictionary Audio: 234 files (42.1 MB) ‚Üí already compressed Scripts: 789 files (8.9 MB) ‚Üí zstd-9 + dictionary Meshes: 89 files (15.6 MB) ‚Üí zstd-7 Other: 279 files (0.03 MB) ‚Üí zstd-3 Training compression dictionaries... Text/Script dictionary: 64KB (3.2x improvement) JSON/Config dictionary: 32KB (2.8x improvement) Building bundle structure... Creating 1,847 asset graphs Building dependency relationships (234 edges) Optimizing graph layout for cache locality Compressing chunks... ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100% (1,847/1,847) Compressed: 1,456 chunks (78.8%) Compression ratio: 3.4:1 Time saved: 89ms per load Computing integrity hashes... BLAKE3 tree: 1,847 leaves, 12 levels Digital signature: Ed25519 Integrity overhead: 0.8% Finalizing bundle... Total size: 47.2 MB (69.8% reduction) Estimated load time: 23ms Memory efficiency: 94% ‚úì Bundle created successfully! Input: 156.3 MB (1,847 files) Output: 47.2 MB (1,247 chunks) Compression: 69.8% size reduction Build time: 3.4 seconds ``` ##### 4. Bundle Analysis (`graphite analyze`) ```bash # Basic analysis graphite analyze assets.graphite # Performance analysis graphite analyze assets.graphite --focus=performance # Compression analysis graphite analyze assets.graphite --focus=compression # Complete analysis with recommendations graphite analyze assets.graphite --detailed --recommendations # Analysis with visualization graphite analyze assets.graphite --visualize --output=analysis_report.html # Comparative analysis graphite analyze assets.graphite --baseline=baseline.graphite Example Output: =============== GRAPHITE Bundle Analysis =============== Bundle: assets.graphite Analysis Time: 234ms Analysis Depth: Comprehensive üìä Structure Analysis: Graphs: 1,247 total - Leaf Graphs (Assets): 1,156 (92.7%) - Collection Graphs: 78 (6.3%) - Transform Graphs: 13 (1.0%) Hierarchy: - Maximum Depth: 8 levels - Average Branching Factor: 3.2 - Strongly Connected Components: 0 (DAG confirmed) - Longest Dependency Chain: 12 nodes üìà Performance Analysis: Load Time Estimates: - Sequential: 89ms (Good) - Parallel (4 threads): 34ms (Excellent) - Parallel (8 threads): 28ms (Excellent) Memory Characteristics: - Arena Size: 89.7 MB - Peak Usage: 94.2 MB - Cache Hit Ratio: 94% (Excellent) - NUMA Efficiency: 87% (Good) Parallelization: - Parallel Groups: 45 (3.6% of graphs) - Critical Path: 23ms - Parallelization Potential: 87% üóúÔ∏è Compression Analysis: Overall Ratio: 3.2:1 (Excellent) By Content Type: - Images: 2.1:1 (already compressed formats) - Scripts: 8.7:1 (high text compression) - Audio: 1.0:1 (no compression, already optimal) - Meshes: 4.2:1 (good binary compression) Dictionary Effectiveness: - Script Dictionary: 3.2x improvement over standard - Config Dictionary: 2.8x improvement over standard - Unused Dictionaries: 0 üîí Integrity Analysis: Hash Tree: BLAKE3, 12 levels, 1,247 leaves Coverage: 100% of chunks protected Verification Time: 23ms (1.2% overhead) Signature: Ed25519, valid Security Features: - Tamper Detection: Enabled - Replay Protection: Enabled - Cryptographic Verification: Enabled üìù String Pool Analysis: Unique Strings: 3,456 Total References: 12,789 Deduplication Ratio: 73% space saved Unused Strings: 23 (0.7%, save 1.2KB) Most Referenced: \"transform\" (342 refs) üéØ Recommendations: Priority 1 (High Impact): ‚ú® Remove 23 unused strings ‚Üí save 1.2KB ‚ú® Reorder chunks by access frequency ‚Üí 12% locality improvement Priority 2 (Medium Impact): üîß Merge 34 small chunks ‚Üí reduce overhead by 2.1KB üîß Add 8 more parallel groups ‚Üí 15% load time improvement Priority 3 (Low Impact): üí° Consider level-9 compression for 23 small text files ‚Üí 0.3KB savings üí° Split 3 large chunks for better streaming ‚Üí streaming improvements Overall Grade: A- (92/100) Performance: A (94/100) Compression: A (91/100) Structure: A- (89/100) Integrity: A+ (98/100) ``` ##### 5. Bundle Optimization (`graphite optimize`) ```bash # Basic optimization graphite optimize assets.graphite # Optimization with backup graphite optimize assets.graphite --backup # Target-specific optimization graphite optimize assets.graphite --target=mobile --memory-limit=256MB # Aggressive optimization graphite optimize assets.graphite --aggressive --allow-quality-loss # Custom optimization profile graphite optimize assets.graphite --profile=optimization_profile.json Example Output: =============== GRAPHITE Bundle Optimization =============== Input Bundle: assets.graphite (47.2 MB) Optimization Target: General (balanced) Backup Created: assets.graphite.backup üîç Analysis Phase: Scanning structure for optimization opportunities... Analyzing compression effectiveness... Evaluating chunk layout and access patterns... Profiling string pool efficiency... ‚ö° Optimization Phase: üì¶ Chunk Optimization: ‚úì Merged 34 small chunks ‚Üí saved 2.1KB overhead ‚úì Split 3 large chunks ‚Üí improved streaming ‚úì Reordered 1,247 chunks by access frequency ‚úì Aligned chunks to cache boundaries üóúÔ∏è Compression Optimization: ‚úì Retrained dictionaries with updated content ‚úì Applied level-9 compression to 23 text files ‚úì Removed compression from 12 pre-compressed files ‚úì Updated compression parameters üîó Structure Optimization: ‚úì Added 8 parallel processing hints ‚úì Optimized dependency order ‚úì Removed 23 unused string references ‚úì Consolidated redundant properties üéØ Layout Optimization: ‚úì Arranged chunks for sequential access ‚úì Grouped related content together ‚úì Minimized memory fragmentation ‚úì Optimized for CPU cache lines ‚úÖ Optimization Complete! Results: Original Size: 47.2 MB Optimized Size: 46.1 MB (2.3% reduction) Performance Improvements: Load Time: 89ms ‚Üí 76ms (14.6% faster) Memory Usage: 94.2 MB ‚Üí 91.8 MB (2.5% less) Cache Hit Ratio: 94% ‚Üí 97% (3% improvement) Quality Metrics: Compression Ratio: 3.2:1 ‚Üí 3.4:1 (improvement) Integrity Overhead: 0.8% ‚Üí 0.7% (slight improvement) Structure Efficiency: 89% ‚Üí 94% (improvement) Total Optimization Time: 1.8 seconds ``` ##### 6. Bundle Benchmarking (`graphite benchmark`) ```bash # Basic benchmark graphite benchmark assets.graphite # Comprehensive benchmark with multiple runs graphite benchmark assets.graphite --runs=10 --detailed # Platform-specific benchmark graphite benchmark assets.graphite --platform=mobile --threads=4 # Comparative benchmark graphite benchmark assets.graphite --compare=assets_v1.graphite,assets_v2.graphite # Benchmark with custom workload graphite benchmark assets.graphite --workload=benchmark_workload.json Example Output: =============== GRAPHITE Bundle Benchmark =============== Bundle: assets.graphite (46.1 MB, 1,247 chunks) Platform: Linux x86_64, 8 cores, 32GB RAM Runs: 10 iterations Confidence Level: 95% üöÄ Load Performance: Sequential Loading: Mean: 76.3ms ¬± 2.1ms Median: 75.8ms 95th Percentile: 80.1ms 99th Percentile: 82.4ms Min: 73.2ms, Max: 84.1ms Parallel Loading (4 threads): Mean: 28.7ms ¬± 1.8ms Median: 28.2ms 95th Percentile: 31.9ms 99th Percentile: 33.1ms Speedup: 2.66x over sequential Parallel Loading (8 threads): Mean: 24.1ms ¬± 1.5ms Median: 23.8ms 95th Percentile: 26.8ms 99th Percentile: 27.9ms Speedup: 3.17x over sequential üíæ Memory Performance: Peak Memory Usage: 91.8 MB ¬± 0.3 MB Arena Allocation: 87.4 MB ¬± 0.1 MB Memory Efficiency: 95.2% ¬± 0.8% Page Faults: 1,247 ¬± 23 (all expected) Memory Access Patterns: L1 Cache Hit Ratio: 97.2% ¬± 0.3% L2 Cache Hit Ratio: 94.8% ¬± 0.5% L3 Cache Hit Ratio: 91.6% ¬± 0.8% Memory Bandwidth Used: 1.2 GB/s ¬± 0.1 GB/s üîç Verification Performance: CRC32 Verification: 8.9ms ¬± 0.4ms (hardware accelerated) BLAKE3 Tree Verification: 23.1ms ¬± 1.2ms Total Integrity Check: 32.0ms ¬± 1.4ms Verification Overhead: 42.0% of total load time üìä Individual Operations: File Mapping: 0.8ms ¬± 0.1ms Header Validation: 0.02ms ¬± 0.01ms Chunk Table Scan: 2.1ms ¬± 0.2ms Arena Allocation: 1.4ms ¬± 0.3ms Decompression: 18.7ms ¬± 1.1ms (856 chunks) Pointer Hydration: 12.3ms ¬± 0.8ms Finalization: 0.6ms ¬± 0.1ms üéØ Task-Specific Benchmarks: Asset Access (Random): Mean: 0.12Œºs ¬± 0.02Œºs (cache hit) Mean: 2.8Œºs ¬± 0.4Œºs (cache miss) Cache Hit Ratio: 97% Graph Traversal (DFS): 100 nodes: 8.4Œºs ¬± 0.6Œºs 1,000 nodes: 84.2Œºs ¬± 3.1Œºs 10,000 nodes: 847Œºs ¬± 24Œºs Property Lookup: String properties: 0.08Œºs ¬± 0.01Œºs Complex properties: 0.31Œºs ¬± 0.04Œºs Array properties: 0.67Œºs ¬± 0.09Œºs üìà Scaling Analysis: CPU Cores vs Load Time: 1 core: 98.7ms 2 cores: 52.3ms (1.89x speedup) 4 cores: 28.7ms (3.44x speedup) 8 cores: 24.1ms (4.09x speedup) 16 cores: 23.8ms (4.15x speedup, saturation) Bundle Size vs Load Time (projected): 10 MB: 18.2ms 50 MB: 76.3ms (current) 100 MB: 147ms 500 MB: 678ms 1 GB: 1.31s üèÜ Performance Grade: A (94/100) Load Speed: A+ (97/100) Memory Efficiency: A (92/100) Scalability: A- (89/100) Consistency: A+ (98/100) Platform Comparison: This system: 76.3ms (baseline) Typical mobile: ~245ms (3.2x slower) High-end desktop: ~52ms (1.5x faster) Cloud instance: ~89ms (1.2x slower) ``` #### Advanced CLI Features ##### 7. Bundle Comparison (`graphite diff`) ```bash # Basic difference graphite diff assets_v1.graphite assets_v2.graphite # Detailed diff with content analysis graphite diff assets_v1.graphite assets_v2.graphite --detailed # Generate patch file graphite diff assets_v1.graphite assets_v2.graphite --patch=update.patch # Visual diff report graphite diff assets_v1.graphite assets_v2.graphite --visual --output=diff_report.html Example Output: =============== GRAPHITE Bundle Comparison =============== Bundle A: assets_v1.graphite (52.1 MB) Bundle B: assets_v2.graphite (46.1 MB) Size Difference: -6.0 MB (-11.5% smaller) üìä Structural Changes: Chunks Added: 23 (new assets) Chunks Removed: 67 (deleted/consolidated) Chunks Modified: 156 (content changes) Chunks Unchanged: 1,068 (85.7%) üìÅ Content Changes: + Added: textures/new_ui_elements.png (2.1 MB) audio/boss_music.ogg (1.8 MB) scripts/new_gameplay_system.js (67 KB) [... 20 more files] - Removed: textures/old_ui/*.png (8 files, 3.2 MB) audio/unused_sfx/ (23 files, 1.1 MB) scripts/deprecated/ (12 files, 89 KB) [... 24 more files] ~ Modified: materials/character_shader.mat (size: 45 KB ‚Üí 52 KB) config/game_settings.json (properties changed) [... 154 more files] üóúÔ∏è Compression Changes: Dictionary Updates: 3 dictionaries retrained Compression Ratio: 3.2:1 ‚Üí 3.4:1 (+6.3% improvement) New Compression: 23 files now compressed Decompression Removed: 12 files (already optimal) ‚ö° Performance Impact: Load Time: 89ms ‚Üí 76ms (-14.6% faster) Memory Usage: 94.2 MB ‚Üí 91.8 MB (-2.5% less) Cache Efficiency: 94% ‚Üí 97% (+3% improvement) üîß Recommendations: ‚úÖ Good: Compression improvements save significant space ‚úÖ Good: Memory usage reduction ‚ö†Ô∏è Warning: 23 new files increase complexity üí° Suggestion: Consider bundling related new assets together Upgrade Path: Patch Size: 8.7 MB (84% smaller than full download) Patch Apply Time: ~150ms Recommended: Use incremental update ``` ##### 8. Bundle Repair (`graphite repair`) ```bash # Auto-repair with backup graphite repair corrupted.graphite --backup # Manual repair with options graphite repair corrupted.graphite \\ --fix-crc-errors \\ --rebuild-string-pool \\ --remove-corrupted-chunks \\ --optimize # Forensic repair with detailed analysis graphite repair corrupted.graphite --forensic --detailed-log Example Output: =============== GRAPHITE Bundle Repair =============== Input: corrupted.graphite (47.2 MB) Backup: corrupted.graphite.backup Repair Mode: Automatic with optimization üîç Corruption Analysis: Scanning file structure... ‚ùå Header: Valid ‚ùå Chunk Table: 3 entries corrupted ‚ùå CRC Errors: 12 chunks affected ‚ùå Hash Tree: 2 branches invalid ‚ùå String Pool: 45 broken references ‚ùå Graph Structure: 7 orphaned nodes üîß Repair Operations: 1. Chunk Table Repair: ‚úì Rebuilt 3 corrupted entries from backup data ‚úì Verified all offset calculations ‚úì Restored missing size information 2. CRC Error Correction: ‚úì Recomputed CRC32 for 12 chunks ‚úì Applied error correction where possible ‚úì Marked 2 chunks as corrupted (data loss) 3. Hash Tree Reconstruction: ‚úì Rebuilt BLAKE3 tree from valid leaves ‚úì Recomputed all branch hashes ‚úì Updated root hash in header 4. String Pool Cleanup: ‚úì Removed 45 broken references ‚úì Rebuilt string index table ‚úì Eliminated 23 orphaned strings 5. Graph Structure Repair: ‚úì Connected 5 orphaned nodes to root ‚úì Removed 2 unreachable nodes (data loss) ‚úì Validated all edge references 6. Optimization (Bonus): ‚úì Recompressed affected chunks ‚úì Defragmented chunk layout ‚úì Updated performance hints ‚úÖ Repair Complete! Results: Repaired Size: 46.8 MB Data Recovery: 97.2% (2.8% loss from corrupted chunks) Integrity: Fully restored Performance: Improved (repair included optimization) Repair Summary: ‚úì Fixed: 67 issues ‚ö†Ô∏è Data Loss: 2 chunks (0.4 MB) üöÄ Improvements: Load time reduced by 8ms Lost Data: - textures/temp_debug.png (corrupted beyond recovery) - audio/test_sound.wav (partial data loss) Repair Time: 2.1 seconds ``` #### Batch Operations and Scripting ##### 9. Batch Processing ```bash # Process multiple bundles graphite batch-validate *.graphite --parallel=4 # Batch optimization graphite batch-optimize assets/*.graphite --target=mobile # Batch conversion graphite batch-convert assets/*.graphite --format=json --output-dir=exports/ # Pipeline processing find assets/ -name \"*.graphite\" | xargs -I {} graphite optimize {} --backup Example Output: =============== GRAPHITE Batch Validation =============== Processing 47 bundles with 4 parallel workers... Progress: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100% (47/47) üìä Summary: Total Bundles: 47 Valid: 43 (91.5%) Invalid: 4 (8.5%) Warnings: 12 bundles Total Size: 2.1 GB Processing Time: 8.7 seconds Average Time/Bundle: 185ms ‚ùå Failed Bundles: level_3_assets.graphite: CRC mismatch in chunk 0x23A old_ui_bundle.graphite: Unsupported format version test_assets.graphite: Corrupted header backup_bundle.graphite: Missing hash tree ‚ö†Ô∏è Warnings: mobile_assets.graphite: 156 unused strings audio_bundle.graphite: Suboptimal compression [... 10 more warnings] üéØ Recommendations: 1. Repair 4 corrupted bundles using 'graphite repair' 2. Optimize 12 bundles with warnings 3. Consider batch optimization for size reduction ``` ##### 10. Configuration and Profiles ```bash # Save optimization profile graphite optimize assets.graphite --save-profile=mobile_profile.json # Use saved profile graphite optimize new_assets.graphite --profile=mobile_profile.json # Global configuration graphite config set default-compression-level 7 graphite config set default-thread-count 8 graphite config set enable-hardware-acceleration true # Project-specific configuration graphite init-project --name=\"MyGame\" --target=mobile # Creates .graphite/config.json with project settings ``` Example Profile (mobile_profile.json): ```json { \"name\": \"Mobile Optimization Profile\", \"description\": \"Optimized for mobile devices with limited memory\", \"compression\": { \"level\": 9, \"enable_dictionary\": true, \"max_dictionary_size\": 32768, \"min_chunk_size\": 1024 }, \"memory\": { \"target_memory_limit\": 268435456, \"prefer_smaller_chunks\": true, \"enable_streaming_hints\": true }, \"performance\": { \"optimize_for_sequential_access\": true, \"enable_parallel_hints\": false, \"cache_locality_priority\": \"high\" }, \"quality\": { \"allow_lossy_compression\": false, \"texture_compression_quality\": 85, \"audio_compression_quality\": 90 } } ``` --- This completes the Command Line Interface section. The CLI provides comprehensive tooling for all aspects of GRAPHITE bundle management, from creation and analysis to optimization and debugging. Each command includes detailed help, progress reporting, and comprehensive output formatting suitable for both interactive use and scripting. Would you like me to continue with the remaining sections of the specification?`, `old_str`: `graphite_binary_diff graphite_create_binary_diff( const graphite_bundle* old_bundle, const graphite_bundle* new_bundle ); graph`, `file_path`: `/home/user/git/graphite/spec_claude.md` }``

Response

`Error: Tool Edit input is invalid: No changes to make: old_string and new_string are exactly the same.`

Retry

Claude hit the maximum length for this conversation. Please start a new conversation to continue chatting with Claude.

[Claude can make mistakes.¬†Please double-check responses.](https://support.anthropic.com/en/articles/8525154-claude-is-providing-incorrect-or-misleading-responses-what-s-going-on)

  

Research

Sonnet 4

[](https://www.anthropic.com/product)

GRAPHITE Asset Graph Format Specification v3.0 **Document Version:** 3.0.0 **Date:** 2025-06-28 **Status:** Production Ready --- ## Table of Contents 1. [Executive Summary](#executive-summary) 2. [Core Principles](#core-principles) 3. [Binary Format](#binary-format) 4. [Graph Structure](

GRAPHITE Naming Origins - Claude